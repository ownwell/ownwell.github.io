<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyning的博客</title>
  
  <subtitle>不抛弃，不放弃，做有意义的事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ownwell.github.io/"/>
  <updated>2018-08-16T16:02:49.556Z</updated>
  <id>http://ownwell.github.io/</id>
  
  <author>
    <name>Cyning</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>试了一把Baidu的语言处理sdk</title>
    <link href="http://ownwell.github.io/2018/08/16/try-baidu-ai/"/>
    <id>http://ownwell.github.io/2018/08/16/try-baidu-ai/</id>
    <published>2018-08-16T15:58:49.000Z</published>
    <updated>2018-08-16T16:02:49.556Z</updated>
    
    <content type="html"><![CDATA[<p>不知怎么滴，一开始都唱衰Baidu的自媒体，突然之间改了风向，改打击腾讯了，看来Robin的在<code>Summer Party</code>上的正能量还是很有用的么？</p><p>今天无意间看了<code>ai.baidu.com</code>发现已经有了语言分析的sdk，于是乎试了一把，挺好用，就过来按理给大家把。</p><p>我用的java版本的语言处理基础技术。<br>先注册，获取appid等应用信息，下载sdk。<br>下面就是很有意思，我其实一直想学习如何给文章打标签。有了这个sdk，瞬间解决l我的问题。</p><p>我从头条上搞到了一条新闻，试了下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sample2</span><span class="params">(AipNlp client)</span> </span>&#123;</span><br><span class="line">        String title = <span class="string">"房叔房婶都跪了！“房祖宗”坐拥 15645 套房产"</span>;</span><br><span class="line">        String content = <span class="string">"港元（约合人民币 2.06 亿元）。其中，减税最多的那位，也就是坐拥 15645 套房产的房祖宗，获得减税额度高达 1.026 亿港元（约合人民币 8200 万元）。另外 9 位，即使是名单中的最后一位，也拥有 1258 套房产，免税额为 890 万港元（约合人民币 713 万元）。"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入可选参数调用接口</span></span><br><span class="line">        HashMap&lt;String, Object&gt; options = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文章标签</span></span><br><span class="line">        JSONObject res = client.keyword(title, content, options);</span><br><span class="line">        System.out.println(res.toString(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>结果很赞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"log_id"</span>: <span class="number">403842984771490524</span>,</span><br><span class="line">  <span class="string">"items"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"score"</span>: <span class="number">0.836735</span>,</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"港元人民币"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"score"</span>: <span class="number">0.80301</span>,</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"购房"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"score"</span>: <span class="number">0.776263</span>,</span><br><span class="line">      <span class="string">"tag"</span>: <span class="string">"房地产业"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>居然给每个标签还打了分。是不是可以为自己的博客，打了个tag呢？</p><p>更多好玩的，还在摊上中……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知怎么滴，一开始都唱衰Baidu的自媒体，突然之间改了风向，改打击腾讯了，看来Robin的在&lt;code&gt;Summer Party&lt;/code&gt;上的正能量还是很有用的么？&lt;/p&gt;
&lt;p&gt;今天无意间看了&lt;code&gt;ai.baidu.com&lt;/code&gt;发现已经有了语言分析的s
      
    
    </summary>
    
      <category term="编程" scheme="http://ownwell.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="AI" scheme="http://ownwell.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>VS code的好用的插件和方便的配置</title>
    <link href="http://ownwell.github.io/2018/08/16/good-tools-for-vs-code/"/>
    <id>http://ownwell.github.io/2018/08/16/good-tools-for-vs-code/</id>
    <published>2018-08-16T15:33:01.000Z</published>
    <updated>2018-08-16T15:43:21.775Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>作为一个Android的开发者，很多时候是和<code>Android Studio</code>打交道，可是他实在太重，于是就习惯了一个很轻盈的文本工具，没错，有很多选择，比如<a href="https://www.sublimetext.com/" target="_blank" rel="noopener">sublimetext</a>,<a href="https://atom.io/" target="_blank" rel="noopener">atom</a>,不过我还是喜欢Vscode，出身贵族(微软)，插件很多，主要是的操作方便，颜值很高，不信，给你图感受下。</p><p><img src="http://pc0oz0yc3.bkt.clouddn.com/1534431572.png?imageMogr2/thumbnail/!70p" alt="图1"></p><p>有没雨觉得很舒服。</p><p>这就给大家介绍几款在使用Vs Code常用的工具或者配置</p><h1 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h1><p><code>VS code</code>集成了很多插件，也有自己的插件应用市场，你可以直接在VS code里面搜索。<br><code>VS code</code>集成的插件如代码高亮，Markdown编辑预览等功能也是很赞的。那我们就给的大家推荐几个我常用的几款插件。</p><h2 id="code-blue"><a href="#code-blue" class="headerlink" title="code blue"></a>code blue</h2><p>如上图中的所示，我们可以看到这样的配合，很保护眼睛，且很美观，很惊艳吧。</p><p>可以直接去<code>VS Code</code>的时长搜索<code>code blue</code>进行下载。</p><h2 id="JSON-Tools"><a href="#JSON-Tools" class="headerlink" title="JSON Tools"></a>JSON Tools</h2><p>这个插件主要是用于格式化，使用它可以直接格式话json<br>markdown插件<br><img src="http://pc0oz0yc3.bkt.clouddn.com/json-format.gif?imageMogr2/thumbnail/!70p" alt=""></p><h2 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a>Material Icon Theme</h2><p>可以是我们的文件看起来很美观哦，这个对于开发html/js可能更适合，会用图标区分每个文件的类型。</p><p><img src="http://pc0oz0yc3.bkt.clouddn.com/1534432446.png?imageMogr2/thumbnail/!70p" alt=""></p><p>## </p><h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><h2 id="配置VS-code到环境变量"><a href="#配置VS-code到环境变量" class="headerlink" title="配置VS code到环境变量"></a>配置<code>VS code</code>到环境变量</h2><p>给我们的code起个别名，使得我们在命令终端就可以直接打开<code>VS code</code>。<br>配置也很简单，只需要在你的shell配置里起个别名形式即可。<br>在<code>~/.zshrc</code>(若你使用的bash，可以在<code>~/.bashrc</code>)下配置如下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p><p>就可以直接在terminal下直接输入<code>code ~/.zshrc</code>直接打开zshrc配置了(有点类似vim)</p><h2 id="markdown-image-alfred"><a href="#markdown-image-alfred" class="headerlink" title="markdown-image-alfred"></a>markdown-image-alfred</h2><p>可以直接将年粘贴板的图上传到七牛，并生成markdown格式的链接,这个是Alfred的一个workflow,可以按照<a href="https://github.com/kaito-kidd/markdown-image-alfred" target="_blank" rel="noopener">markdown-image-alfred</a>介绍来一步步配置，我现在上传图片还是很方便的，只需好复制，<code>command+shift+ V</code>就生成了一个<code>markdown</code>格式的链接了。<br>。<br>如下图的操作。</p><p><img src="http://pc0oz0yc3.bkt.clouddn.com/markdown-pic.gif?imageMogr2/thumbnail/!70p" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;作为一个Android的开发者，很多时候是和&lt;code&gt;Android Studio&lt;/code&gt;打交道，可是他实在太重，于是就习惯了一个很轻盈的文本工具，没错，有很多选择，比如&lt;a href=&quot;https://www.sublimetext.co
      
    
    </summary>
    
      <category term="Tools" scheme="http://ownwell.github.io/categories/Tools/"/>
    
    
      <category term="VS code" scheme="http://ownwell.github.io/tags/VS-code/"/>
    
  </entry>
  
  <entry>
    <title>Gradle插件开发(1)</title>
    <link href="http://ownwell.github.io/2018/07/30/android-gradle_1/"/>
    <id>http://ownwell.github.io/2018/07/30/android-gradle_1/</id>
    <published>2018-07-30T13:52:10.000Z</published>
    <updated>2018-08-08T11:28:38.305Z</updated>
    
    <content type="html"><![CDATA[<p>目前的开发工具主要是在Android Studio上，对这个工具真的是又恨又爱，只能收希望它越来越好。<br>这几天，一直在看Gradle插件的相关的东西，希望将自己的这些学习成长的经历记录下来。由易到难，开发一个自己的插件。</p><blockquote><p>准备工作</p><ol><li>Android Studio(建议3.0+)</li><li>gradle 4.0+</li></ol></blockquote><a id="more"></a><p>我们需要开发一个能打印<code>hello world</code>的gradle插件,看到hello world，是不是觉得凉凉了，哈哈，一个好的程序员都是从hello world开始的，千里之行始于足下。<br>我们希望希望开发一个简单的插件，就是打印一行：hello world。</p><p>先解释下，所以的gradle的插件，其实就是一个可以挂载在我们工作空间的一个工具，但我们运行我们的gradle脚本时，我们就可以运行我们的插件，这个插件是为我们做一些人工也可以替代的工作，甚至是多个task任务。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a><a name=""></a>项目结构</h2><p>我们先在我们的工作控件新建一个Android library项目plugin，仅保留src下的main其他的都删掉吧.</p><p><img src="http://pc0oz0yc3.bkt.clouddn.com/MacHi%202018-08-01%2022-28-39_20188122298.png" alt="20188122298"></p><p>src/main下新建一个groovy和resources的文件夹。<br>其中groovy的文件用来存源码，resources存放静态资源和配置，build.gradle是我们的build环境。<br>先来看下build.gradle吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'groovy'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//gradle sdk</span></span><br><span class="line">    <span class="function">compile <span class="title">gradleApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//groovy sdk</span></span></span><br><span class="line"><span class="function">    compile <span class="title">localGroovy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">repositories </span>&#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>一个插件的主要工作其实是在src文件下，所以我们需要在<code>src/main/groovy</code>下新建一个文件包名<code>cc.cyning.plugin</code>，在这个包下新建一个<code>MyPlugin.groovy</code>文件。<br>MyPlugin.groovy文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在groovy下不是应该用groovy语言么？<br>其实用java也是ok的,对于不会groovy的同学用java肯定是可以的。</p></blockquote><p>插件实现了<code>org.gradle.api.Plugin</code>接口，我们需要实现<code>apply</code>方法。</p><p>插件的工作完成，可是怎么标识<code>MyPlugin</code>文件是插件的入口文件呢？</p><p>在<code>src/main/resources</code>下我们需要定义一个<code>properties</code>文件：</p><p>resources<br><br>&nbsp;&nbsp;└── META-INF<br><br> &nbsp;&nbsp;&nbsp;&nbsp; └── gradle-plugins<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└── cyning.properties<br></p><p> cyning.property：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span></span>=cc.cyning.plugin.MyPlugin</span><br></pre></td></tr></table></figure></p><p>这样就是一个完整的插件项目的结构，groovy是我们的实现代码，·、<code>resources/META-INF</code>配置插件的实现类。</p><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a><a name="-1"></a>插件使用</h2><h3 id="maven-本地仓库配置"><a href="#maven-本地仓库配置" class="headerlink" title="maven 本地仓库配置"></a><a name="maven"></a>maven 本地仓库配置</h3><p>为了插件的使用，我们需要引入maven本地仓库，怎么上传远程仓库，可以参考我的另外一篇拙作：<a href="http://ownwell.github.io/2016/07/14/push-library-to-jcenter/">开源自己的项目到JCenter</a>,不过为了插架开发没必要这么麻烦。</p><blockquote><p>若是你了解可以直接跳过本小节内容。</p></blockquote><p>我们需要在<code>build.gradle</code>下配置上传到本地的maven配置：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'groovy'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">group=<span class="string">'cc.cyning.plugin'</span></span><br><span class="line">version=<span class="string">'1.0.0'</span></span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">//提交到远程服务器：</span></span><br><span class="line">            <span class="comment">// repository(url: "http://www.xxx.com/repos") &#123;</span></span><br><span class="line">            <span class="comment">//    authentication(userName: "admin", password: "admin")</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//本地的Maven地址设置为在项目的maven文件下（提前新建mave这个文件夹）</span></span><br><span class="line">            repository(<span class="string">url:</span> <span class="string">"file://$&#123;rootProject.projectDir&#125;/maven"</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>./gradlew :plugin:uploadArchives</code>即可在项目下看到maven文件下产生了文件：</p><p><img src="http://pc0oz0yc3.bkt.clouddn.com/MacHi%202018-08-01%2023-02-28_20188123242.png" alt="20188123242"></p><p>而我们的项目怎么用呢？</p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a><a name="-1"></a>使用插件</h3><p>上一步，我们已经生成maven插件，为了能让插件运行，我们需要导入这个gradle插件。<br>app的<code>build.gradle</code>配置：</p><figure class="highlight groovy"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;<span class="comment">//本地Maven仓库地址 切记：三个斜杠，</span></span><br><span class="line">            url <span class="string">"file:///$&#123;rootProject.projectDir&#125;/maven/"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">//格式为--&gt;group:module:version</span></span><br><span class="line">        classpath <span class="string">'cc.cyning.plugin:plugin:1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cyning为resources/META-INF/gradle-plugins</span></span><br><span class="line"><span class="comment">//下的properties文件名称</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'cyning'</span></span><br></pre></td></tr></table></figure><p>运行我们的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">./gradlew :app:clean            </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Configure project :app </span></span><br><span class="line">========================</span><br><span class="line">hello world</span><br><span class="line">========================</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a name="-1"></a>小结</h2><p>我们这节的目的就是能熟悉插件的卡法流程，尤其是开发插件和使用的各种配置，要对应上，properties的配置，以及gradle使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前的开发工具主要是在Android Studio上，对这个工具真的是又恨又爱，只能收希望它越来越好。&lt;br&gt;这几天，一直在看Gradle插件的相关的东西，希望将自己的这些学习成长的经历记录下来。由易到难，开发一个自己的插件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;准备工作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Android Studio(建议3.0+)&lt;/li&gt;
&lt;li&gt;gradle 4.0+&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://ownwell.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>JNI开发笔记（2） -- Native要校验APP安全</title>
    <link href="http://ownwell.github.io/2018/05/02/jni-security-4-app/"/>
    <id>http://ownwell.github.io/2018/05/02/jni-security-4-app/</id>
    <published>2018-05-02T13:52:10.000Z</published>
    <updated>2018-08-08T11:32:26.141Z</updated>
    
    <content type="html"><![CDATA[<p>由于使用NDK开发，可以中间的数据放入到so中，这样是的关键数据更安全。因为破解原生代码相对来说太容易，而so文件相对来说门槛较高。<br>我们本篇就是从安全角度来使用NDK开发，将重要的数据放入NDK中，同时将重要的加密也放入到NDK开发，这样在一定程度上可以保证APP应用的安全。<br><a id="more"></a></p><h1 id="校验APK安装包信息"><a href="#校验APK安装包信息" class="headerlink" title="校验APK安装包信息"></a>校验APK安装包信息</h1><h2 id="获取应用包名"><a href="#获取应用包名" class="headerlink" title="获取应用包名"></a>获取应用包名</h2><p>在<a href="http://ownwell.github.io/2018/05/02/JNI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">上篇文章</a>中,我们可以通过NDK的方法来获取APK的包名。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jstring</span><br><span class="line">JNICALL</span><br><span class="line">Java_me_cyning_helloworld_NativeUtils_getPackageName(</span><br><span class="line">        JNIEnv *env, jclass clazz, jobject instance) &#123;</span><br><span class="line">    jclass nativeClass = env-&gt;GetObjectClass(instance);</span><br><span class="line">    jmethodID jmethodID1 = env-&gt;GetMethodID(nativeClass, <span class="string">"getPackageName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    jstring packageName = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(instance, jmethodID1));</span><br><span class="line">    <span class="keyword">return</span>  packageName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java层调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">native</span> String <span class="title">getPackageName</span><span class="params">(Context context)</span></span>;</span><br></pre></td></tr></table></figure></p><p> 但是在实际的应用中，能不能不传Context来获取到全文的Context呢？答案是可以的！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; activityThreadClzz = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentApplication =  activityThreadClzz.getMethod(<span class="string">"currentApplication"</span>);</span><br><span class="line">Application application = (Application) currentApplication.invoke(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><p>我们可以参考：<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/app/ActivityThread.java#1827" target="_blank" rel="noopener">ActivityThread</a>。由于<code>currentApplication</code>是个静态方法，可以通过反射获取到一个Application对象。</p><p>结合之前的代码我们可以合并如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">getApplication</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    jobject application = NULL;</span><br><span class="line">    jclass activity_thread_clz = env-&gt;FindClass(<span class="string">"android/app/ActivityThread"</span>);</span><br><span class="line">    <span class="keyword">if</span> (activity_thread_clz != NULL) &#123;</span><br><span class="line">        <span class="comment">// 得到ActivityThread的currentApplication的静态方法id</span></span><br><span class="line">        jmethodID currentApplication = env-&gt;GetStaticMethodID(</span><br><span class="line">                activity_thread_clz, <span class="string">"currentApplication"</span>, <span class="string">"()Landroid/app/Application;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentApplication != NULL) &#123;</span><br><span class="line">            <span class="comment">// 调用ActivityThread的静态方法，返回结果application</span></span><br><span class="line">            application = env-&gt;CallStaticObjectMethod(activity_thread_clz, currentApplication);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGE(<span class="string">"Cannot find method: currentApplication() in ActivityThread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        env-&gt;DeleteLocalRef(activity_thread_clz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"Cannot find class: android.app.ActivityThread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> application;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jstring  <span class="title">getPackageName</span><span class="params">( JNIEnv *env,jobject instance )</span> </span>&#123;</span><br><span class="line">    jclass nativeClass = env-&gt;GetObjectClass(instance);</span><br><span class="line">    jmethodID jmethodID1 = env-&gt;GetMethodID(nativeClass, <span class="string">"getPackageName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    jstring packageName = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(instance, jmethodID1));</span><br><span class="line">    <span class="keyword">return</span>  packageName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据context来获取包名</span></span><br><span class="line">extern <span class="string">"C"</span> JNIEXPORT jstring</span><br><span class="line">JNICALL</span><br><span class="line">Java_me_cyning_helloworld_NativeUtils_getPackageName(</span><br><span class="line">        JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    <span class="keyword">return</span>  getPackageName(env, getApplication(env));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是得到包名就安全了么，NO！有些”居心不良”的人可能会改我的包签名，好了那怎么就校验下包签名，不合法的APP让它直接GG。<br>怎么获取包签名信息呢？</p><h2 id="获取应用的签名信息"><a href="#获取应用的签名信息" class="headerlink" title="获取应用的签名信息"></a>获取应用的签名信息</h2><p>怎么获取一个APP的签名信息呢？还是和获取包名一样，我们需要拿到在java上的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">           PackageInfo pi = pm.getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">           Signature[] signatures = pi.signatures;</span><br><span class="line">           Signature signature0 = signatures[<span class="number">0</span>];</span><br><span class="line">           String string = signature0.toCharsString();</span><br></pre></td></tr></table></figure><p>用NDK怎么实现呢？<br>若是你不知道C怎么调用java，这是个很好的学习范例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span> JNIEXPORT jint</span><br><span class="line">JNICALL</span><br><span class="line">        Java_me_cyning_helloworld_NativeUtils_getSignature(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取context</span></span><br><span class="line">    jobject  context_obj = getApplication(env);</span><br><span class="line">    <span class="comment">// 获取到context的类</span></span><br><span class="line">    jclass  context_clazz  = env-&gt;GetObjectClass(context_obj);</span><br><span class="line">    jstring  packageName = getPackageName(env, context_obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到context中的getPackageManager的方法id</span></span><br><span class="line">    jmethodID  getPackageManagerMethod = env-&gt;GetMethodID(context_clazz, <span class="string">"getPackageManager"</span>, <span class="string">"()Landroid/content/pm/PackageManager;"</span>);</span><br><span class="line">    <span class="comment">// 调用getPackageManager方法，获取到PackageManager对象</span></span><br><span class="line">    jobject pm_obj = env-&gt;CallObjectMethod(context_obj, getPackageManagerMethod);</span><br><span class="line"></span><br><span class="line">    jclass  pm_clazz  = env-&gt;GetObjectClass(pm_obj);</span><br><span class="line">    jmethodID  getPackageInfoMethod = env-&gt;GetMethodID(pm_clazz, <span class="string">"getPackageInfo"</span>, <span class="string">"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"</span>);</span><br><span class="line">    jobject  packageInfo_obj = env-&gt;CallObjectMethod(pm_obj, getPackageInfoMethod, packageName, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    jclass  pi_clazz  = env-&gt;GetObjectClass(packageInfo_obj);</span><br><span class="line">    <span class="comment">//  Signature[] signatures = pi.signatures; 返回值是数组[]</span></span><br><span class="line">    jfieldID signatures_field = env-&gt;GetFieldID(pi_clazz, <span class="string">"signatures"</span>, <span class="string">"[Landroid/content/pm/Signature;"</span>);</span><br><span class="line"></span><br><span class="line">    jobject signatures = env-&gt;GetObjectField(packageInfo_obj, signatures_field);</span><br><span class="line">    jobjectArray signatures_array = (jobjectArray) signatures;</span><br><span class="line"></span><br><span class="line">    jobject signature0 = env-&gt;GetObjectArrayElement(signatures_array, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    jclass  signature_clazz  = env-&gt;GetObjectClass(signature0);</span><br><span class="line">    jmethodID  toCharsStringMethod = env-&gt;GetMethodID(signature_clazz, <span class="string">"toCharsString"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    jstring  signature_string = (jstring)env-&gt;CallObjectMethod(signature0, toCharsStringMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    env-&gt;DeleteLocalRef(context_obj);</span><br><span class="line">    env-&gt;DeleteLocalRef(context_clazz);</span><br><span class="line">    env-&gt;DeleteLocalRef(packageName);</span><br><span class="line">    env-&gt;DeleteLocalRef(pm_obj);</span><br><span class="line">    env-&gt;DeleteLocalRef(pm_clazz);</span><br><span class="line">    env-&gt;DeleteLocalRef(packageInfo_obj);</span><br><span class="line">    env-&gt;DeleteLocalRef(pi_clazz);</span><br><span class="line">    env-&gt;DeleteLocalRef(signatures);</span><br><span class="line">    env-&gt;DeleteLocalRef(signature0);</span><br><span class="line">    env-&gt;DeleteLocalRef(signatures_array);</span><br><span class="line">    env-&gt;DeleteLocalRef(signature_clazz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> signature_string;</span><br></pre></td></tr></table></figure></p><p>实现的对应代码:<br><img src="http://7xwwa2.com1.z0.glb.clouddn.com/2018-05-03-21-54-19.png" alt=""></p><p>这样就可以将获取的签名和本地的签名比较：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sign = env-&gt;GetStringUTFChars(signature_string, NULL);</span><br><span class="line">   <span class="keyword">int</span> result = strcmp(sign,</span><br><span class="line">                       <span class="string">"app的签名"</span>);</span><br><span class="line">   env-&gt;ReleaseStringUTFChars(signature_string, sign);</span><br><span class="line">   env-&gt;DeleteLocalRef(signature_string);</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="number">0</span>) &#123; <span class="comment">// 签名一致</span></span><br><span class="line">       <span class="keyword">return</span> JNI_OK;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> JNI_ERR;</span><br></pre></td></tr></table></figure></p><p>重写<code>JNI_OnLoad</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = NULL;</span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (verifySign(env) == JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGE(<span class="string">"签名不一致!"</span>);</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就会在<code>System.loadLibrary(&quot;native-lib&quot;);</code>时，就会调用<code>JNI_OnLoad</code>,当签名不一致时就会直接导致崩溃。</p><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p> 当然了，我们也可以在NDK层实现加密，如网络请求时，将参数加密等，这样相对来说：</p><ol><li>安全 底层实现的加密不易破解</li><li><p>高效 c实现的加密相对来说速度快，效率高</p><p>具体的代码可以参考这篇<a href="http://blog.majiajie.me/2016/04/12/NDK%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86%E5%BA%93-Codec/" target="_blank" rel="noopener">文章</a>,不过可以根据需求来自己定义加密算法。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于使用NDK开发，可以中间的数据放入到so中，这样是的关键数据更安全。因为破解原生代码相对来说太容易，而so文件相对来说门槛较高。&lt;br&gt;我们本篇就是从安全角度来使用NDK开发，将重要的数据放入NDK中，同时将重要的加密也放入到NDK开发，这样在一定程度上可以保证APP应用的安全。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="JNI开发" scheme="http://ownwell.github.io/tags/JNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JNI开发笔记（1）- 入门</title>
    <link href="http://ownwell.github.io/2018/04/27/JNI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://ownwell.github.io/2018/04/27/JNI开发笔记（1）/</id>
    <published>2018-04-27T13:52:10.000Z</published>
    <updated>2018-08-08T11:30:55.148Z</updated>
    
    <content type="html"><![CDATA[<p>Android Studio 3.0 更新了很多新特性，其中对C++开发者也越来越友好。目前Android Studio默认构建工具是CMake（当然也是支持ndk-build），我们将使用Cmake来开始编写我们的Helleworld。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p> 更新我们的sdk-tool中的LLDB、CMake和NDK三个选项。</p><p><img src="http://7xwwa2.com1.z0.glb.clouddn.com/MacHi%202018-05-02%2021-19-17.png" alt=""></p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>可以先创建一个helloWorld项目来看下它和普通的Android项目的区别。<br><img src="http://7xwwa2.com1.z0.glb.clouddn.com/2018-05-02-21-25-11.png" alt=""></p><p><img src="http://7xwwa2.com1.z0.glb.clouddn.com/2018-05-02-21-25-59.png" alt=""></p><p>这样一步步的next创建了一个简单的Helleworld的用CMake作为构建工具的JNI程序。</p><p>来看下它和普通的Android程序的区别吧。</p><p><img src="http://7xwwa2.com1.z0.glb.clouddn.com/2018-05-02-21-32-48.png" alt=""></p><p>这三处使我们和一般应用程序中所没有的，所以我们在普通程序中添加这三处也是可以添加自己的c/c++代码的。</p><ol><li><p>cpp文件夹使我们的c/c++代码代码的目录，这和src是我们的源代码目录类似。</p></li><li><p><code>CMakeLists.txt</code>是和Gradle交互的一个桥梁，里面的内容类似于我们之前写的make文件。</p></li><li><p>在主APP下要写两处<code>externalNativeBuild</code>,一处是可以根据处理的来打某一个平台的so文件，而另一处是为了将<code>CMakeLists.txt</code>和Gradle构建关联。</p></li></ol><p>运行项目，通过<code>Analyze APK</code>是可以直接看到打出来的APK是有这个so的。</p><blockquote><p>配置某个平台（如x86）的so</p></blockquote><p>如上图上的标记3，在第一处添加cpu对应的架构：</p><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">            ndk &#123;</span><br><span class="line">                abiFilters  <span class="string">'x86'</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            ndk &#123;</span></span><br><span class="line"><span class="comment">//                abiFilters 'x86', 'x86_64', 'armeabi-v7a',  'arm64-v8a','armeabi'</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写一个简单的JNI程序"><a href="#编写一个简单的JNI程序" class="headerlink" title="编写一个简单的JNI程序"></a>编写一个简单的JNI程序</h2><p>之前在网易工作时，发现网易系的有些应用是通过so文件来保证数据校验，如加密一个字符串，同时会传一个Context，这样可以通过context来校验是不是正版应用，校验应用的安全信息。我们就来实现一个通过Context来获取包名。</p><ol><li><p>native方法<br>我们是通过java代码调用native方法，所以先声明一个native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.cyning.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">native</span> String <span class="title">getPackageName</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>native代码<br>在我们的<code>native-lib.cpp</code>来实现具体的功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jstring</span><br><span class="line">JNICALL</span><br><span class="line">Java_me_cyning_helloworld_NativeUtils_getPackageName(</span><br><span class="line">        JNIEnv *env, jclass clazz, jobject instance) &#123;</span><br><span class="line">    jclass nativeClass = env-&gt;GetObjectClass(instance);</span><br><span class="line">    jmethodID jmethodID1 = env-&gt;GetMethodID(nativeClass, <span class="string">"getPackageName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    jstring packageName = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(instance, jmethodID1));</span><br><span class="line">    <span class="keyword">return</span>  packageName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>让我们来解释下：</p><ul><li>函数签名：Java-(包名+类型+函数)(参数)</li><li><p>jni编程的类型和java类型的区别<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/944365-e2d3218e2bf0934f.png" alt=""></p></li><li><p>JNI 函数访问 Java 对象的变量<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/2018-05-02-22-35-22.png" alt=""></p></li></ul><p>结合上面的具体代码，很容易理解，先拿到<code>Context</code>对应的class类，通过这个类得到<code>getPackageName</code>方法的id，通过<code>CallObjectMethod</code>这个<code>Context</code>实例的<code>getPackageName</code>方法，看着很像反射的用法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/cloverjf/article/details/78652245" target="_blank" rel="noopener">https://blog.csdn.net/cloverjf/article/details/78652245</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android Studio 3.0 更新了很多新特性，其中对C++开发者也越来越友好。目前Android Studio默认构建工具是CMake（当然也是支持ndk-build），我们将使用Cmake来开始编写我们的Helleworld。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="JNI开发" scheme="http://ownwell.github.io/tags/JNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>白话ACSCII，GBK，Unicode，UTF-8</title>
    <link href="http://ownwell.github.io/2018/04/01/introduce-to-unicode/"/>
    <id>http://ownwell.github.io/2018/04/01/introduce-to-unicode/</id>
    <published>2018-04-01T13:48:26.000Z</published>
    <updated>2018-04-01T13:55:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>ACSCII，GBK，Unicode，UTF-8这些名词都跟编码有关系，究竟是什么关系呢，看网上的确有很多解释，也很详尽，不过我觉得还是很有必要把我自己学习的历程记录下来。</p><h1 id="ACSCII码"><a href="#ACSCII码" class="headerlink" title="ACSCII码"></a>ACSCII码</h1><p>在计算机的世界是只有0和1，数据的计算，传输，保存等过程都是通过0和1，可以说0和1是组成计算机的元素。<br>对于最早使用计算机的美国人，为了记录a，b，c，d等这些字母，1，2，3等还有其他的符号，共收集了128个(2的7次方)，于是为了更好记录就有了ASCII（American Standard Code for Information Interchange，美国信息互换标准代码，ASCⅡ）码，可以看下每个符号对应的ACSCII码。</p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/2018-03-27_21-33-06.png" alt=""><br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/2018-03-27%2021-33-56.png" alt=""><br>这对于使用英语的人已经满足了人的大部分需求，因为有了26个字母，有了数字和各种控制符，就可以玩转计算机。但是，随着计算机传入我们国家，ACSCII码肯定不够用，怎么办？</p><h1 id="GB-2312以及GBK"><a href="#GB-2312以及GBK" class="headerlink" title="GB 2312以及GBK"></a>GB 2312以及GBK</h1><p>早先的ASCII编码字符集由于受到单字节的限制。随着国内计算机的发展，中国国家标准总局发布了一套《信息交换用汉字编码字符集》的国家标准，其标准号就是<strong>GB 2312</strong>。这个字符集共收入汉字6763个和非汉字图形字符682个,同时，收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。整个字符集分成94个区，每区有94个位。，具体的编码表可以参照<a href="http://tools.jb51.net/table/gb2312" target="_blank" rel="noopener">GB2312简体中文编码表</a>。</p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/2018-03-27%2022-00-06.png" alt="第03区"></p><p>可以通过上面的第03区的编码表看到每个区位对应一个字符，因此可用所在的区和位来对汉字进行两字节编码。</p><p>实际上，GB2312收录的只是常用汉字，对于一些生僻字，繁体字，GB2312依然不够，于是又有了后来的GBK字符集以及编码规范，但GBK是兼容GB2312的。</p><p>相信GBK和GB2312也是大最常见的字符集，但是这只是对国内的计算机，对于一些希腊字母以及其他国外的文字，怎么通信呢？这就需要一个国际化的字符集或者标准，于是unicode编码就在这种情况下诞生啦。</p><h1 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h1><p>在<code>ACSCII码</code>满足不了非英语系的语言后，出现了各种各样的编码格式如简体汉字的GBK字符集，台湾繁体的Big5字符集（大五码），日语的JIS等等各自为战，这对于国际化来说是一个很纠结的问题，打开一个网页若是不知道是什么编码就可能是一篇乱码的火星文。于是有人提出了搞一个国际化的标准Unicode。 Unicode最初我们常见肯定是两个字节的，也就是说16位，如汉字的“李”对应的Unicode就是<code>674E</code>，这样对于大部分的非英语系的文字是没有问题的。但是，对于之前说过的<code>ACSCII码</code>采用两个字节的太浪费.若是<code>ACSCII码</code>若是采用两个字节的话，第一个字节的都是0填充，而低位才是真正有效的，这杨来看，对于经常使用英文字母（包含在<code>ACSCII码</code>）的歪果仁来说，这个Unicode一点都不高效。所以怎么高效传送Unicode呢？也是出现了后来各式各样的编码方式：UTF-8，UTF-16，UTF-32，但是我们常用的可能就是UTF-8，UTF-16。</p><p>那么怎么用utf-16来表示一个字符呢，需要先讲下具体的规则。<br>UTF-16是目前各大操作系统和框架支持比较好的编码方式，可以认为它是双字节的，如上文所述，采用16位存储的方式。</p><p><code>UTF-8</code>则是将一些比较长的字符，按照一定的规则分成若干个八位来存储，同时兼容<code>ACSCII码</code>。<br>对于只需要7位都可以存储的：<br>0XXXXXXX<br>若是超过7位的，则是需要在高位来存储表示来表示整个编码的长度：<br>如110XXXXX 10XXXXXX 两个字节，一个字节是一个单元，其中其中110表示这个编码串的长度是2<br>，10是低位单元的前缀。所以有效字符应该是去掉110和后面的10，<br>1110XXXX 10XXXXXX 10XXXXXX 三个字节，110表示三个字节，后面的两个10是低位单元的前缀。</p><p>如李的UTF-8编码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 李 16进制</span></span><br><span class="line">E6 9D 8E</span><br><span class="line"><span class="comment"># 李 16进制</span></span><br><span class="line">11100110 10011101 10001110</span><br></pre></td></tr></table></figure></p><p>当我们把110 10去掉后，发现其实他就是UTF-16对应的<code>674E</code>。UTF-8转UTF-16，其实是就是将每个单元的前缀(110,10)去掉，后不够一个字节的，在第一个字节的高位用0填充。<br>如汉字李的UTF-8编码：</p><ol><li>由于第一个单元的高位含有三个1，可知和紧随其后的两个字节是一个完整的字</li><li>去掉1110 10得到<code>0110 011101 001110，正好16位，得到的结果为：</code>674E`</li></ol><p>所以当我们需要自己编码或者转码时，只需要参照UTF-8的学习方法即可，谨以此文，抛砖引玉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ACSCII，GBK，Unicode，UTF-8这些名词都跟编码有关系，究竟是什么关系呢，看网上的确有很多解释，也很详尽，不过我觉得还是很有必要把我自己学习的历程记录下来。&lt;/p&gt;
&lt;h1 id=&quot;ACSCII码&quot;&gt;&lt;a href=&quot;#ACSCII码&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="编程" scheme="http://ownwell.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://ownwell.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据分析--NBA哪个月的比赛最多</title>
    <link href="http://ownwell.github.io/2018/03/25/python-data-analysis-nba-01/"/>
    <id>http://ownwell.github.io/2018/03/25/python-data-analysis-nba-01/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-04-01T16:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>我是个NBA伪球迷，去打篮球很少，但是天天看球赛，什么NBA，CBA甚至连NCAA的八强赛也关注，前几天接触Python的数据分析，发现挺有意思，于是我就自己搞了一个简单的程序来分析—从96-97赛季开始，平均哪个月的NBA比赛最多。<br><a id="more"></a></p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>我自己喜欢搞爬虫，自己爬了一点数据到数据库，至于怎么爬取，请关注公众号:<strong>爱代码的Cyning</strong>，后续会将爬虫代码程序发出来。<br>我将爬取的数据放到了Mysql的数据库，大概的数据如下：<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/20180401230409.png" alt=""></p><h3 id="数据库连接和数据获取"><a href="#数据库连接和数据获取" class="headerlink" title="数据库连接和数据获取"></a>数据库连接和数据获取</h3><ul><li><strong>安装pymysql</strong> </li></ul><p>目前使用的是Python3.5+，那么Python怎么链接Mysql呢？<br>首先需要安装<code>pymysql</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i http://pypi.douban.com/simple --trusted-host pypi.douban.com pymysql</span><br></pre></td></tr></table></figure></p><ul><li>获取数据库的数据</li></ul><p>跟其他语言获取数据库方式一样，拿到游标就可以拿到数据:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>  MySQLdb.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'root'</span>, port=<span class="number">3306</span>, db=<span class="string">"nba"</span>) <span class="keyword">as</span> cursor:</span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    sql = <span class="string">"select * from `match-time`"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        p = np.array(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"Error: unable to fecth data"</span>)</span><br><span class="line">        <span class="keyword">return</span> np.nan</span><br></pre></td></tr></table></figure></p><p>通过<code>MySQLdb</code>库来拿到数据库的游标，执行sql语句，就可以通过<code>.fetchall()</code>获取数据库中所有的列表信息。</p><ul><li>Numpy分析</li></ul><p>在Python3.X上开发是个很开心的过程，因为Python平台下丰富的第三方库，为我们提供了各式各样的轮子，我们只需要按照自己的需求组装或者组合。我们可以通过Numpy库来处理目前我们能拿到的数据。</p><p>上面的<code>np.array</code>其实就是将从数据库的二维数据向量化。</p><p>我们需要将1996-1997赛季到2016-2017赛季所有的按照月份给列出来，首先我们需要获取每隔赛季有哪几个月是比赛月(常规赛和季后赛)，因为每隔赛季的情况千差万别，如停摆，全明星赛，以及各种因素会导致每隔赛季有所差异。</p><p>那我们如何拿到每隔赛季的月份呢:</p><ol><li>过滤2017-2018赛季（比赛尚未结束）</li><li>按照月份来去重，拿到有比赛的月份(比赛月)</li><li>每一个的比赛求总和</li></ol><p><strong>过滤2017-2018赛季以及求月份</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从数据库获取数据</span></span><br><span class="line">data_arr = getAllData()</span><br><span class="line"><span class="comment">#  过滤2017-2018赛季</span></span><br><span class="line">data_arr = data_arr[  (data_arr[:, <span class="number">6</span>] != <span class="string">"2017-2018"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到月份</span></span><br><span class="line">month_list = np.unique(data_arr[:, <span class="number">4</span>])</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span> <span class="string">'10'</span> <span class="string">'11'</span> <span class="string">'12'</span> <span class="string">'2'</span> <span class="string">'3'</span> <span class="string">'4'</span> <span class="string">'5'</span> <span class="string">'6'</span>]</span><br></pre></td></tr></table></figure></p><p>跟实际情况是一致的。</p><p><strong>求每个月份比赛数</strong></p><p>只需将刚才的比赛月一一遍历，求和即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">month_list_result = []</span><br><span class="line"><span class="keyword">for</span> month <span class="keyword">in</span> month_list:</span><br><span class="line">    <span class="comment"># 和month相同的月份的向量</span></span><br><span class="line">    month_list_data = data_arr[data_arr[:,<span class="number">4</span>] == month]</span><br><span class="line">    <span class="comment"># 求和，Y轴</span></span><br><span class="line">    match_cnt = np.sum(month_list_data[:, <span class="number">1</span>].astype(int), axis=<span class="number">0</span>)</span><br><span class="line">    month_list_result.append([month, match_cnt])</span><br></pre></td></tr></table></figure></p><p>将获取的<code>month_list_result</code>存到csv文件中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_name = os.path.join(<span class="string">"./"</span>,   <span class="string">"month_cnt.csv"</span>)</span><br><span class="line">save_stats_to_csv(np.array(month_list_result), file_name, headers=[<span class="string">'month'</span>, <span class="string">"match_cnt"</span>])</span><br></pre></td></tr></table></figure></p><ul><li>结果</li></ul><p>打开csv文件，用excel的图标展示如下:<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/201804012343.png" alt=""></p><p>通过这个图，我们很容易知道：<strong>NBA 3月份的比赛最多</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是个NBA伪球迷，去打篮球很少，但是天天看球赛，什么NBA，CBA甚至连NCAA的八强赛也关注，前几天接触Python的数据分析，发现挺有意思，于是我就自己搞了一个简单的程序来分析—从96-97赛季开始，平均哪个月的NBA比赛最多。&lt;br&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://ownwell.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="http://ownwell.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>（译文）手把手教你用Java实现AOP</title>
    <link href="http://ownwell.github.io/2018/03/20/aop/"/>
    <id>http://ownwell.github.io/2018/03/20/aop/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-04-01T14:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>众所周知，AOP（面向切面编程）是web框架Spring的特色功能之一。通过设置横切关注点（cross cutting concerns），AOP提供了极高的扩展性。<br><a id="more"></a><br>那AOP在Spring中是怎样运作的呢？当你只能使用core java，却需要AOP技术时，这个问题的解答变得极为关键。不仅如此，在高级技术岗位的面试中，此类问题也常作为考题出现。这不，我的朋友最近参加了一个面试，就被问到了这样一个棘手的问题——如何在不使用Spring及相关库，只用core Java的条件下实现AOP。因此，我将在本文中提供一份大纲，帮助大家了解如何只用core Java实现一个AOP（当然啦，这种AOP在功能上有一定的局限性）。注意，本文不是一篇有关Spring AOP与Java AOP的对比研究，而是有关在core Java中借助固有的设计模式 。</p><p>想必大家已经知道AOP是什么，也知道在Spring框架中如何使用它，因此本文只着眼于如何在不用Spring的前提下实现AOP。首先，我们得知道，Spring是借助了JDK proxy和CGlib两种技术实现AOP的。JDK dynamic proxy提供了一种灵活的方式来hook一个方法并执行指定的操作，但执行操作时得有一个限制条件：必须先提供一个相关的接口以及该接口的实现类。实践出真知，让我们透过一个案例来理解这句吧！现在有一个计算器程序，用于完成一些数学运算。让我们来考虑下除法功能，此时的问题是：如果core framework 已经具备了一份实现除法的代码，我们能否在代码执行时劫持（highjack）它并执行额外的校验呢？答案是肯定的，我将用下面提供的代码片段来证明这点。首先来看基础接口的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口实现类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们既不能修该上面的代码，也不能对核心库进行任何改动，怎样才能完美地实现校验功能呢？不如试下JDK dynamic proxy的功能吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code omitted for simplicity…..</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// Your complex business validation and logic</span></span><br><span class="line">        Object result = method.invoke(targetObject ,params);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们通过测试类来看看由JDK dynamic proxy实现的校验功能的效果如何。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CalculatorImpl calcImpl = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">        Calculator proxied = (Calculator)ProxyFactory.getProxy (Calculator.class, calcImpl, </span><br><span class="line">                <span class="keyword">new</span> SomeHandler(calcImpl));</span><br><span class="line">        <span class="keyword">int</span> result = proxied.calculate(<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"FInal Result :::"</span> + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，简单地实现功能强大的<strong>InvocationHandler</strong>接口，我们便能得到一个hooking implementation。按照JDK文档的描述，<strong>InvocationHandler</strong>接口是借助一个代理实例（proxy instance）来处理一个方法调用的。</p><p>现在我们已经知道，InvocationHandler的invoke()方法能够帮助我们解决问题。那么再来解决一个新问题——怎样才能在方法执行的前后执行操作呢？说的更具体一些，我们能通过添加多个aop（before、after、around）来hook一个方法吗（译注：原文为add multiple aops，但我认为Handler是充当Aspect的角色）？答案同样是肯定的。按照以下的步骤建立一个精简的代码模板便能满足这样的需求：</p><ol start="2"><li>创建一个抽象类，用于将aop应用于目标对象上。</li><li>创建名为BeforeHandler 和 AfterHandler的两个aop。前者在方法执行之前工作，而后者则在方法执行结束后工作。</li><li>创建一个代理类，使所有的aop handler和目标对象只需作为参数传入，就能创建一个hook。</li><li>加入你自己的业务逻辑或者横切关注点。</li><li>最后，通过传入相关的参数创建代理对象（proxy object）。</li></ol><h3 id="技术实现概要"><a href="#技术实现概要" class="headerlink" title="技术实现概要"></a>技术实现概要</h3><p>（译注：此处是核心代码片段，如果想运行该实例，需进入下方提供的链接下载完整代码）</p><p>创建一个handler的抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetObject</span><span class="params">(Object targetObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建名为<strong>BeforeHandler</strong>和<strong>AfterHandler</strong>的两个易扩展的handler抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeHandler</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleBefore</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">handleBefore(proxy, method, args);</span><br><span class="line"><span class="keyword">return</span> method.invoke(getTargetObject(), args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterHandler</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleAfter</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object result = method.invoke(getTargetObject(), args);</span><br><span class="line">handleAfter(proxy, method, args);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Proxy的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object targetObject,</span></span></span><br><span class="line"><span class="function"><span class="params">List handlers)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Code to get the proxy</span></span><br><span class="line"><span class="keyword">return</span> proxyObject;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> targetObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CalculatorImpl calcImpl = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">BeforeHandler before = <span class="keyword">new</span> BeforeHandlerImpl();</span><br><span class="line">AfterHandler after = <span class="keyword">new</span> AfterHandlerImpl();</span><br><span class="line">List&lt;AbstractHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;AbstractHandler&gt;();</span><br><span class="line">handlers.add(before);</span><br><span class="line">handlers.add(after);</span><br><span class="line">Calculator proxy = (Calculator) ProxyFactory.getProxy(calcImpl,</span><br><span class="line">handlers);</span><br><span class="line"><span class="keyword">int</span> result = proxy.calculate(<span class="number">20</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>以上的代码片段简明扼要地解释了AOP在结构上的实现（structural implementation）。当然，如果能通过实际的测试将其运用到现实中去，那就再好不过了。读者可在下面的链接中获取完整的工程文件，并在Java编辑器中配置它们，最后通过其中的测试类来检验效果。</p><ul><li><a href="https://github.com/debjava/aopusingjdkdynamicproxy" target="_blank" rel="noopener">https://github.com/debjava/aopusingjdkdynamicproxy</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望这篇简短的有关AOP文章能够帮助到大家。需说明的是，本文只实现了before和after两种aop，而另外两种，即“Around”和“Throw”，则希望读者自行完成。</p><hr><p>原文：<a href="https://www.javacodegeeks.com/2015/03/create-your-own-aop-in-java.html" target="_blank" rel="noopener">Create your own AOP in Java</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;众所周知，AOP（面向切面编程）是web框架Spring的特色功能之一。通过设置横切关注点（cross cutting concerns），AOP提供了极高的扩展性。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://ownwell.github.io/categories/Java/"/>
    
    
      <category term="译文" scheme="http://ownwell.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Center OS下安装常用软件</title>
    <link href="http://ownwell.github.io/2018/03/19/server-install-apps/"/>
    <id>http://ownwell.github.io/2018/03/19/server-install-apps/</id>
    <published>2018-03-19T13:39:28.000Z</published>
    <updated>2018-03-19T15:07:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在腾讯云上买了个服务器，3年多,这也是为自己学习的投资。拿到新机器，我们需要搭常见的环境，如java，python等，中间一顿折腾，后来居然还重置了机器。今天就把周末自己折腾的结果整理下，防止有人进坑。</p><h1 id="安装python环境"><a href="#安装python环境" class="headerlink" title="安装python环境"></a>安装python环境</h1><p>python不必多说，是各种语言（Java，Oc，sh脚本）的粘合剂，提供丰富的库，语言简洁，人生苦短，我用Python。</p><p>安装Python可以去下载Python3.x（不要再用Python2.7了!!），也可以通过<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">Anaconda</a>安装。</p><p>我推荐使用<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">Anaconda</a>安装，能省去很多体力活。下面就开始安装Anaconda:</p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/MacHi%202018-03-19%2022-30-36.png" alt=""><br>DownLoad实际上是个sh文件，我们通过wget来下载,并通过sh来执行这个安装文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.continuum.io/archive/Anaconda3-5.1.0-Linux-x86_64.sh</span><br><span class="line"></span><br><span class="line">sh Anaconda3-5.1.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>然后执行这个脚本，就进入安装步骤。</p><p>只要安装完Anaconda，pyhton就安装成功了，对了和数据分析的，Numpy等工具库都已经安装成功。</p><h1 id="安装java8"><a href="#安装java8" class="headerlink" title="安装java8"></a>安装java8</h1><p>Java是我我接触时间比较久的语言，所以必须安装它，首选Java8.</p><ol><li><p>下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "http://download.oracle.com/otn-pub/java/jdk/8u162-b12/0da788060d494f5095bf8624735fa2f1/jdk-8u162-linux-x64.rpm”</span><br></pre></td></tr></table></figure></li><li><p>yum 安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall jdk-<span class="number">8</span>u162-linux-x64.rpm -y</span><br></pre></td></tr></table></figure></li><li><p>配置<br>这样java就安装到<code>/usr/java/jdk1.8.0_162</code>.在自己的shell的配置文件(如bash的.bashrc)配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_162</span><br><span class="line">export JRE_HOME=/usr/java/jdk1.8.0_162/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure></li></ol><p>最后通过<code>java -version</code>验证下。</p><h1 id="mysql的安装和配置"><a href="#mysql的安装和配置" class="headerlink" title="mysql的安装和配置"></a>mysql的安装和配置</h1><p>安装mysql走了点弯路，不过没关系，后面居然都是很顺利的。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>之前我用<code>yum install mysql</code> 是没问题的，但是安装<code>mysql-server</code>  时提示没找到，于是就搜了下，还需要添加yum源.</p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/2018-03-19-01.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="string">'https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm'</span></span><br><span class="line"></span><br><span class="line">sudo rpm -Uvh mysql57-community-release-el7-<span class="number">11</span>.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum repolist all | grep mysql</span><br></pre></td></tr></table></figure><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/2018-03-19_02.png-blog" alt=""></p><p>就找到5.7的，开始安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure></p><h1 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h1><p>开启mysql的服务：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysqld start </span><br><span class="line">sudo systemctl start mysqld</span><br><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure></p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/MacHi%202018-03-19_03.png-blog" alt=""></p><h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><p>这个密码让我纠结很久，因为我想登录mysql，但是发现我没有密码！！<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p  <span class="comment">#输入mysql密码</span></span><br></pre></td></tr></table></figure></p><p>后来记得我之前在mac安装时会有个临时密码弹窗，感觉在linux也类似。上网查了下果然如此，只需要找到这个临时密码，再重设置就OK。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grep <span class="string">'temporary password'</span> /var/<span class="built_in">log</span>/mysqld.lo查看到的密码</span><br></pre></td></tr></table></figure></p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/MacHi%202018-03-19_04.png" alt=""></p><p>再通过密码登录mysql数据库，设置密码:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p  <span class="comment">#输入mysql临时密码</span></span><br><span class="line"></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'root1244'</span>; <span class="comment"># 登录mysql设置新密码root1244</span></span><br></pre></td></tr></table></figure></p><p>退出mysql后，就可以快乐使用了。</p><blockquote><p>5.6之后有个安全设置，可以重置密码，修改数据库是否可以被远程访问等<code>mysql_secure_installation</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在腾讯云上买了个服务器，3年多,这也是为自己学习的投资。拿到新机器，我们需要搭常见的环境，如java，python等，中间一顿折腾，后来居然还重置了机器。今天就把周末自己折腾的结果整理下，防止有人进坑。&lt;/p&gt;
&lt;h1 id=&quot;安装python环境&quot;&gt;&lt;a href=&quot;#安
      
    
    </summary>
    
      <category term="编程" scheme="http://ownwell.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="服务器" scheme="http://ownwell.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>模拟下Retrofit的动态代理</title>
    <link href="http://ownwell.github.io/2018/03/11/dynamic-proxy-for-retrofit/"/>
    <id>http://ownwell.github.io/2018/03/11/dynamic-proxy-for-retrofit/</id>
    <published>2018-03-10T16:00:00.000Z</published>
    <updated>2018-04-02T15:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Retrofit是目前使用的最Six的网络请求框架，他具有很好的拓展性，支持Xml，Json，Protobuf等协议，调度上支持RxJava，Guava，Java8等方式。为了更好理解Retrofit，我看了下他的源码，发现Square就是牛，代码分层清晰，可复用性强，提供的API对开发者友好诸多优点，虽然用到了反射，但是依然不影响它的优美之处。</p><h1 id="模仿Retrofit"><a href="#模仿Retrofit" class="headerlink" title="模仿Retrofit"></a>模仿Retrofit</h1><p>对于Retrofit我们可以通过一个接口，生成一个对象，这个是如何做到的呢？一开始我就是带着这个问题来看源码的，为了更好理解我自己模拟了Retrofit的实现方式，我们也给这个关键类起名叫Retrofit，其使用方式如下。</p><p>code 1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dynamicproxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="class"><span class="keyword">interface</span> <span class="title">VPN</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Url</span>(<span class="string">"twitter.con"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">visitNetwork</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="class"><span class="keyword">interface</span> <span class="title">ChinaNetwork</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Url</span>(<span class="string">"baidu.com"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">visitNetwork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        VPN vpn = <span class="keyword">new</span> Retrofit().create(VPN.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(vpn.visitNetwork());;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是<code>new Retrofit().create(VPN.class)</code>让我满脸的疑惑，现在我们可以看下<code>visitNetwork</code>的结果，实际上是打印的<code>twitter.con</code>.若是我们把<code>VPN</code>换成<code>ChinaNetwork</code>,打印的是<code>baidu.com</code>.</p><p>这个API是不是和Retrofit有几分神似?</p><p>我们可以知道拿到Url注解里的value其实不难，可以参考之前注解的文章，主要拿到了这个方法，就可以获得和它相关的注解。</p><p>那么，怎么生产一个通过接口生成一个对象呢，其实很简单，就是动态代理？</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理不是什么新词，在Java里很多框架都是基于动态代理实现的，动态代理在很大程度上解决了解耦的问题，不像静态代理（或者继承）那样强关联。<br>在了解动态代理前，我们需要先了解一个静态方法。<br>java.lang.reflect.Proxy的newProxyInstance方法，它需要三个参数：</p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/MacHi%202018-04-02%2022-22-31.png" alt=""></p><ol><li>ClassLoader 这个是我们加载class中很必要的。</li><li>Class[] 这个实际上就是我们需要使用动态代理的接口或者抽象类</li><li>InvocationHandler 实际上就是这个对象在运行中的回调，并返回对应函数的结果。</li></ol><p>可以结合code1的代码来实现我们的动态代理类：<br>code 2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;service&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">                        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">                        String html = <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Url) &#123;</span><br><span class="line">                                String url = ((Url) annotation).value();</span><br><span class="line">                                System.out.println(<span class="string">"访问的页面: "</span> + url);</span><br><span class="line">                                html = <span class="string">"&lt;html &gt; "</span> + url + <span class="string">" &lt;/html&gt;"</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">                        <span class="keyword">return</span> html;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Retrofit2.0通过注解拿到我们配置的各种参数，如请求方法，url，请求参数等，再通过动态代理生成一个新的VPN或者ChinaNetwork对象来处理这些参数，像code2中我们可以通过拿到的url参数，来进行请求网页等其他操作，但对于程序的入口类是无感知的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Retrofit是目前使用的最Six的网络请求框架，他具有很好的拓展性，支持Xml，Json，Protobuf等协议，调度上支持RxJava，Guava，Java8等方式。为了更好理解Retrofit，我看了下他的源码，发现Square就是牛，代码分层清晰，可复用性强，提供
      
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="动态代理" scheme="http://ownwell.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习03-函数</title>
    <link href="http://ownwell.github.io/2018/03/03/kotlin-learning-03/"/>
    <id>http://ownwell.github.io/2018/03/03/kotlin-learning-03/</id>
    <published>2018-03-03T11:45:02.000Z</published>
    <updated>2018-03-03T13:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin的语言很简洁，或许可以通过lambda表达式就能惊叹它很优秀，不过函数或许也是它更出彩的地方。</p><p>在开始前，我们需要认识到很多类，如集合类，Kotlin其实是基于Java的api，只是对Java类的API又做了拓展，丰富了其API，而不是推倒重建，在JVM重做一套，所以Kotlin是很大一部分API是基于Java对应的API实现的。但是可能会有疑惑为什么Kotlin的集合类有那么丰富的API呢？ </p><p>可以用下面的例子来验证下：在Kotlin中，计算数组的最大值其简单，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val persons = listOf(</span><br><span class="line">        Person(<span class="string">"cyning"</span>, <span class="number">21</span>),</span><br><span class="line">        Person(<span class="string">"gaodaren"</span>, <span class="number">18</span>),</span><br><span class="line">        Person(<span class="string">"damei"</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">println(persons.maxBy(Person::age))</span><br></pre></td></tr></table></figure><p> 若是去打印person的类型，会发现实际上它是java的类型</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(persons.maxBy(Person::age))</span><br></pre></td></tr></table></figure><p> 打印：<br> <code>class java.util.Arrays$ArrayList</code>.<br> 这正验证了刚才咱们说的：Kotlin在很多实细节上是基于<code>java</code>实现的。</p><h3 id="带默认值的函数"><a href="#带默认值的函数" class="headerlink" title="带默认值的函数"></a>带默认值的函数</h3><p>在开始前需要了解下函数的默认参数值，在其他语言如<code>python</code>, 不是什么新鲜玩意儿。</p><p>所谓带参数值的函数，实际上在调用函数时，选择性指定参数，否则函数验证按照参数个数，类型，顺序查找到对应签名的函数。</p><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">update</span><span class="params">(name:String, age:Int = <span class="number">0</span>, address:String = <span class="string">""</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//todo do somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上我们不为函数传值age和address，他可以走默认值0和””,也可以指定的传一个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update(<span class="string">"cyning"</span>, <span class="number">18</span>)</span><br><span class="line">update(<span class="string">"cyning"</span>, address = <span class="string">"china"</span>)</span><br></pre></td></tr></table></figure><p>这样一个函数可以提供多个参数的同时，确保了某些参数使用默认值。</p><blockquote><blockquote><p>为了保证java能调起来Kotlin的带默认值的参数，我们需要在Kotlin中用@JvmOverloads来确保多个同名函数的重载</p></blockquote></blockquote><h3 id="顶层的函数"><a href="#顶层的函数" class="headerlink" title="顶层的函数"></a>顶层的函数</h3><p>顶层参数主要是为了解决类似utils工具类的问题，函数可以在类的顶层（不在类的内部），调用时，类似调用java的静态工具类。</p><p>对于java调用kotlin的顶层函数，需要注意导入的类是这个函数所在的类名加Kt后缀。</p><h3 id="拓展函数"><a href="#拓展函数" class="headerlink" title="拓展函数"></a>拓展函数</h3><p>在Kotlin中，我们是可以为其他类添加函数，好像是这个函数本身有的方法一样。这样的函数我们称之为拓展函数。定义规则如下：</p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/201803032056_class_litlkjdksjfkjfks.png" alt=""></p><p>这样String就多个一个方法lastChar()函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun  String.lastChar():Char = <span class="keyword">this</span>.get(length-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"cyning li"</span>.lastChar()</span><br></pre></td></tr></table></figure></p><p>其中=后面的可以理解成是在String类的操作（其中的this自己体会下）</p><p>若嫌不够，再来一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun  List&lt;Int&gt;.maxElem():Int  &#123;</span><br><span class="line">    var max:Int = <span class="keyword">this</span>.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.forEach &#123; <span class="comment">//this实际上就是接收者对象</span></span><br><span class="line">        max = (<span class="keyword">if</span>  (it &gt; max) it <span class="keyword">else</span> max )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">val  list = listOf&lt;Int&gt;(<span class="number">20</span>, <span class="number">4</span>, <span class="number">67</span>, <span class="number">90</span>);</span><br><span class="line">println(list.maxElem())</span><br></pre></td></tr></table></figure><p>其中的forEach的this实际上是指List<int>的一个对象。</int></p><p>在其他Kotlin使用，只需要导入相关的包名，类名，拓展方法名，就可以正常使用了，类似于调用顶层函数。</p><blockquote><p>所有拓展方法调用的方法都必须是接收类型的共有方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kotlin的语言很简洁，或许可以通过lambda表达式就能惊叹它很优秀，不过函数或许也是它更出彩的地方。&lt;/p&gt;
&lt;p&gt;在开始前，我们需要认识到很多类，如集合类，Kotlin其实是基于Java的api，只是对Java类的API又做了拓展，丰富了其API，而不是推倒重建，在
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://ownwell.github.io/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://ownwell.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习02-lambda表达式 </title>
    <link href="http://ownwell.github.io/2018/03/01/kotlin-learning-02/"/>
    <id>http://ownwell.github.io/2018/03/01/kotlin-learning-02/</id>
    <published>2018-03-01T14:25:08.000Z</published>
    <updated>2018-03-01T16:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉间，2月份就过去，也就是说2018年已经过去了六分之一，再细想真可怕。<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/f774ac0904410c6d7dc77afc86cea5f8%20.png" alt=""></p><p>今天继续<code>Kotlin</code>的学习,主要从<code>lambda</code>的历史，定义，和集合的函数API，以及推荐使用的<code>with</code>和<code>apply</code>两个常用的函数。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。在<code>Java8</code>中，加入了lambda表达式，可以简化代码，方便开发者开发更高效的代码。</p><p>其表达式很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(argument) -&gt; (body)</span><br></pre></td></tr></table></figure><p><code>lambda</code>编码了一小块你可以用作一个值进行传递的行为。它可以被独立的声明并存储在一个变量中。但是更常见的是，当它被传递给一个函数时直接声明。在<code>Kotlin</code>中，一个<code>lambda</code>表达式往往被一个大括号所包围,如下段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123; x: Int, y: Int -&gt; x + y &#125;</span><br></pre></td></tr></table></figure><p>用java实现可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好简化代码，<code>lambda</code>表达式也是越来越简短，我们就用点击一个button时，打印对应的view的id，如代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn?.setOnClickListener(&#123; v -&gt;</span><br><span class="line">           print(v.id)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当<code>lambda</code>表达式作为参数时，且是参数列表里的最后一个参数，可以把{}放到外面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn?.setOnClickListener()&#123; v -&gt;</span><br><span class="line">           print(v.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当lambda是函数的唯一参数时，你也可以删掉空的圆括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn?.setOnClickListener&#123; v -&gt;</span><br><span class="line">           print(v.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="集合的函数式API"><a href="#集合的函数式API" class="headerlink" title="集合的函数式API"></a>集合的函数式API</h2><p>函数式风格代码，简化了代码，使得代码不被各种逻辑分离，其中集合也提供一些常见的函数式API，使得我们的开发事半功倍。</p><h3 id="filter和map"><a href="#filter和map" class="headerlink" title="filter和map"></a>filter和map</h3><p>记得之前学习RxJava时有这两个函数，在Kotlin中其实也很类似，可以参考RxJava来理解这两个函数(<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Filter.html" target="_blank" rel="noopener">filter</a>, <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Map.html" target="_blank" rel="noopener">map</a>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val nums = listof(<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">list.filter&#123; it % <span class="number">2</span> == <span class="number">0</span>&#125; <span class="comment">//  偶数</span></span><br></pre></td></tr></table></figure><p>打印结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>filter里面实际上返回的是个boolean值，只有返回值为true才会被留下，当然返回值依然是之前的类型（如例子中的list返回依然是list）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val nums = listof(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">list.map&#123; it *it &#125; <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>打印结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><h3 id="预言：all-any-count和find"><a href="#预言：all-any-count和find" class="headerlink" title="预言：all, any, count和find"></a>预言：all, any, count和find</h3><p>all是所有都满足指定条件（预言）才返回true，any则判断至少有一个满足条件，find则查找第一个指定条件，count表示满足预言的元素个数。</p><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><p>将指定维度的条件分组，将指定维度下的相同元素进行分组，返回是map类型<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/33cb401b621d0d06bc19caf4fc87b566%20.png" alt=""></p><h2 id="with和apply函数"><a href="#with和apply函数" class="headerlink" title="with和apply函数"></a>with和apply函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">alphabet</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">    val result = StringBuilder()</span><br><span class="line">    <span class="keyword">for</span> (letter in <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        result.append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(<span class="string">"\nNow I know the alphabet!"</span>)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在代码大量使用<code>result</code>, 写起来很是麻烦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">alphabet</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">    val stringBuilder = StringBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> with(stringBuilder) &#123;                <span class="comment">// 1　在你调用的方法中制定接收器的值</span></span><br><span class="line">        <span class="keyword">for</span> (letter in <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.append(letter)                 <span class="comment">// 2 通过显式的“this”调用接收器值的方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        append(<span class="string">"\nNow I know the alphabet!"</span>)   <span class="comment">// 3 调用方法，忽略“this”</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.toString()                        <span class="comment">// 4　从lambda中返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文中的this都可以都可以忽略，不过有时需要alphabet内写这个类的this对象时，可以声明变量来实现。</p><p>apply基本上使用和with类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">alphabet</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">    val stringBuilder = StringBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StringBuilder().apply &#123;                <span class="comment">// 1　在你调用的方法中制定接收器的值</span></span><br><span class="line">        <span class="keyword">for</span> (letter in <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.append(letter)                 <span class="comment">// 2 通过显式的“this”调用接收器值的方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        append(<span class="string">"\nNow I know the alphabet!"</span>)   <span class="comment">// 3 调用方法，忽略“this”</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 4　从lambda中返回值</span></span><br><span class="line">    &#125;.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者的不同主要在返回值，用with返回值不是<code>stringBuilder</code>自己的类型，而apply返回则仍然是<code>StringBuilder</code>类型。</p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/8856b545cc3a45aa283ec43cd0587940.png-blog" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉间，2月份就过去，也就是说2018年已经过去了六分之一，再细想真可怕。&lt;br&gt;&lt;img src=&quot;http://7xj9f0.com1.z0.glb.clouddn.com/f774ac0904410c6d7dc77afc86cea5f8%20.png&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://ownwell.github.io/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://ownwell.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习01-基础</title>
    <link href="http://ownwell.github.io/2018/02/26/learning-kotlin-1/"/>
    <id>http://ownwell.github.io/2018/02/26/learning-kotlin-1/</id>
    <published>2018-02-26T06:15:55.000Z</published>
    <updated>2018-05-03T14:29:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin的学习笔记。<br><a id="more"></a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="函数-变量"><a href="#函数-变量" class="headerlink" title="函数 变量"></a>函数 变量</h2><ol><li>main函数可以独立于class</li><li><p>静态函数<br>类的静态函数，需要通过将函数放入到companion object的大括号内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">       <span class="function">fun <span class="title">add</span><span class="params">( a: Int,  b:Int)</span>:Int </span>=  (</span><br><span class="line">             a + b</span><br><span class="line">               )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    Static.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    println(<span class="string">"Hello, $&#123;if (args.size &gt; 0) args[0] else "</span>someone<span class="string">"&#125;!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常量用val，变量用var </p><h2 id="类和属性"><a href="#类和属性" class="headerlink" title="类和属性"></a>类和属性</h2></li><li><p>自定义的获取器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle(val height: Int, val width: Int) &#123;</span><br><span class="line">    val isSquare: Boolean</span><br><span class="line">        get() &#123;    <span class="comment">// 属性的获取函数声明</span></span><br><span class="line">            <span class="keyword">return</span> height == width</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Kotlin源代码布局</p><ol><li>Kotlin并没有在导入类和函数之间做区别,可以直接import方法，类似python和ReactJs的用法。</li><li>可以把多个类放到同一个文件中并且可以为文件选择任意的名字，弱化了包的概念</li></ol></li></ol><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举和java中的有很大的相似之处，可以自己定义参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> class <span class="title">Color</span><span class="params">(val r :Int, val g :Int, val b :Int)</span> </span>&#123;<span class="comment">// 1 声明枚举常量的属性</span></span><br><span class="line">    RED(<span class="number">255</span>, <span class="number">0</span>, <span class="number">9</span>), ORANGE(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="comment">// 2 当每个常量被创建时指定属性值</span></span><br><span class="line"></span><br><span class="line">    YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), GREEN(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), BLUE(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line"></span><br><span class="line">    INDIGO(<span class="number">75</span>, <span class="number">0</span>, <span class="number">130</span>), VIOLET(<span class="number">238</span>, <span class="number">130</span>, <span class="number">238</span>); <span class="comment">// 3 分号（;）在这里是必须的</span></span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">rgb</span><span class="params">()</span> </span>= (r * <span class="number">256</span> + g) * <span class="number">256</span> + b        <span class="comment">// 4 在枚举类中定义了一个方法</span></span><br></pre></td></tr></table></figure></p><p>不同之处在于：</p><ol><li>enum class 来标识是枚举</li><li>在枚举中的常量，需要用分号隔开，kotlin中唯一一处需要必须用分开的地方<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2>when在处理枚举时，有点类似于java的switch-case，不过在kotlin中可以直接使用表达式函数。</li></ol><h3 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">fun <span class="title">getMnmonic</span><span class="params">(color: Color)</span> </span>=        <span class="comment">// 1 直接返回一个when表达式</span></span><br><span class="line">            when (color) &#123;                    <span class="comment">// 2 如果颜色等于枚举常量，返回对应的字符串</span></span><br><span class="line">                Color.RED -&gt; <span class="string">"Richard"</span></span><br><span class="line">                Color.ORANGE -&gt; <span class="string">"Of"</span></span><br><span class="line">                Color.YELLOW -&gt; <span class="string">"York"</span></span><br><span class="line">                Color.GREEN -&gt; <span class="string">"Grave"</span></span><br><span class="line">                Color.BLUE -&gt; <span class="string">"Battle"</span></span><br><span class="line">                Color.INDIGO -&gt; <span class="string">"In"</span></span><br><span class="line">                Color.VIOLET -&gt; <span class="string">"Vain"</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">"Dirty color"</span>)  <span class="comment">// 3 如果没有一个分支被匹配，将执行该语句</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>对应多个条件满足同一个返回结果，可以：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.RED, Color.ORANGE, Color.YELLOW -&gt; <span class="string">"warm"</span></span><br></pre></td></tr></table></figure></p><p>还有一个分支是默认分支，可以通过else的方式返回。</p><h3 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h3><p>对于多个参数的，每次都要写参数，会很多余，可以直接不用参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">when &#123;    <span class="comment">// 不带参数的when</span></span><br><span class="line">       (c1 == RED &amp;&amp; c2 == YELLOW) ||</span><br><span class="line">       (c1 == YELLOW &amp;&amp; c2 == RED) -&gt;</span><br><span class="line">           ORANGE</span><br><span class="line"></span><br><span class="line">       (c1 == YELLOW &amp;&amp; c2 == BLUE) ||</span><br><span class="line">       (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt;</span><br><span class="line">           GREEN</span><br><span class="line"></span><br><span class="line">       (c1 == BLUE &amp;&amp; c2 == VIOLET) ||</span><br><span class="line">       (c1 == VIOLET &amp;&amp; c2 == BLUE) -&gt;</span><br><span class="line">           INDIGO</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">"Dirty color"</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h3><p>在java中，在调用一个是其他类型的对象时，若是object对象，我们需要先转成对应的类型，而后再处理，但是在kotlin不需要，只要判断是某个类型后，可以直接调用这个类具有的属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expr</span></span></span><br><span class="line">class Num(val value: Int) : Expr        // 1 带有一个属性、值而且实现了Expr接口的简单的值对象类</span><br><span class="line">class Sum(val left: Expr, val right: Expr) : Expr    // 2 求和操作的参数可以是任意的Expr：Num对象或者其他的Sum对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">eval</span><span class="params">(e: Expr)</span>: Int </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e is Num) &#123;</span><br><span class="line">        val n = e as Num        <span class="comment">// 1 显式的Num类型转换是多余的 </span></span><br><span class="line">        <span class="keyword">return</span> e.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e is Sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> eval(e.right) + eval(e.left)    <span class="comment">// 2 变量e是智能类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown expression"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    println(eval(Sum(Sum(Num(<span class="number">1</span>), Num(<span class="number">2</span>)), Num(<span class="number">4</span>))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kotlin的学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://ownwell.github.io/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://ownwell.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>狗年，再出发</title>
    <link href="http://ownwell.github.io/2018/02/22/dog-year-plain/"/>
    <id>http://ownwell.github.io/2018/02/22/dog-year-plain/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-02-27T05:02:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/27336955_1912123552151043_5553721495423153257_n.jpg-blog" alt=""><br>狗年，来了，我也二十九了，老家有个习俗，逢九入十，这样一算我就三十了，三十而立，而今我还没立。<br><a id="more"></a><br>现在我要给自己写一封信，来告诉已经三十岁的自己，狗年你才真正出发。</p><hr><p>狗年是旺的一样，你要自信面对以前的三十年，是是三十年，让你有了现在的自己，虽然不够努力，可你至少没有沉沦，而今的你才需要规划自己，狗年，这样一年，你需要更加努力，更加勤奋，更加自信走自己的路。<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/894a2c13eb84f41_w303_h200.gif" alt=""></p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>   我希望你能正确面对工作，这是你的本分工作，无论别人怎么夸赞你，你都要认识到自己的不足，无论别人怎么质疑你，你都要认识到自己的优秀之处，不卑不亢，快乐前行。</p><p>   我不希望你看着你踮着脚尖，我希望你脚踏实地。</p><p>   我希望你能将自己的所学能集中到你的项目中，将自己的产品打造成你的符号。</p><p>   我希望你能在工作之余，写写博客，将自己的工作中的一些总结汇聚成你自己知识的财富。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>  我觉得狗年，适合学习，因为汪汪更适合告诉别人，你可以加油努力，一切似乎都要旺。</p><p>  我狗年的目标给自己的规划是：</p><ol><li><p>至少每两周一次博客的更新，求精不求多，同步到自己的各个技术账号上。</p></li><li><p>每个月至少一本书，记得写读书笔记。技术类的可能很繁杂，希望你能自己总结，写读书笔记或者总结。 </p></li><li>搭建一个自己的网站，我发现我这有一些很好玩的书，我希望自己搭建一个自己的电子书网站，前期可能考虑限制下载。</li><li>学习机器学习的课程，未来是AI的天下，不会这个是不是有点落后，谁知道未来的趋势呢，不过跟着谷歌爸爸肯定是没有错的。</li></ol><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>  去年，我家的领导找到了工作，今年可以在一起了，以后一切就是这个小家庭，所有生活上，主要围绕自己的大家庭和小家庭。</p><p>  狗年的规划：</p><ol><li>每天贵在坚持的锻炼，每周固定的出行，考虑去做义工（尝试性）；固定和家人联系，无论在哪里家人都是家人，一个嘘寒问暖，一句相互问候，都能给你带来家的温暖。</li><li>结婚，结婚旅行。</li></ol><p>希望戊戌狗年，能坚持，能继续努力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xj9f0.com1.z0.glb.clouddn.com/27336955_1912123552151043_5553721495423153257_n.jpg-blog&quot; alt=&quot;&quot;&gt;&lt;br&gt;狗年，来了，我也二十九了，老家有个习俗，逢九入十，这样一算我就三十了，三十而立，而今我还没立。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://ownwell.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="2018" scheme="http://ownwell.github.io/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>爱自己</title>
    <link href="http://ownwell.github.io/2017/12/04/love-yourself/"/>
    <id>http://ownwell.github.io/2017/12/04/love-yourself/</id>
    <published>2017-12-04T14:54:08.000Z</published>
    <updated>2017-12-04T14:58:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>经历了一些事情，让我们增加的不仅仅是我们的知识，更多的是这些事情也在改变我们的心态，如前几日得知我的一位同学身犯重病，我们所有人都在诧异的同时也在反思着，万一是我呢，思虑了几天，总觉得该把这些记录下来，为自己，，也为了自己爱的人，我们是时候来深刻反思自我啦。<br><a id="more"></a></p><p>或许脑子里，不断重复的是我之前读过的一个故事，故事是讲一个流浪汉说自己很穷，遇到了一个刚从医院出来的富翁，流浪汉就上去乞讨，富翁很生气，流浪汉反诘道：『你是如此的富有，为什么不施舍给我点吃饭的钱呢』，富翁用严厉的语气问道：『小伙子，我愿意用100w买一双健康的眼睛，你愿意买给我么』，流浪汉摇摇头；富翁又问到：【我愿意用200w买你的心脏，来治疗我的心脏病，你愿意么】，流浪汉又摇摇了头，富翁终于用平和的语气说道【孩子，你是富有的，因为你拥有健康，你年轻这就是你最大的资本啊】。<br>虽然故事有演绎色彩（本人不善于讲故事）,但是其中的道理是值得我们深思的，珍惜你现在拥有的健康，年轻。</p><h1 id="理想"><a href="#理想" class="headerlink" title="理想"></a>理想</h1><p>『不想当将军的士兵不是个好士兵』，是一句很励志的名言。他告诉我们要有梦想，梦想是指引我们前进的最大动力；其次，这是告诫我们要高标准要求自己，一般情况下你你期望总是低于你实际奋斗的果实，你要求自己得优，可能你得到的是良，你要求自己的是良，有可能你得到的是差。</p><p>每个人在心里一定要有理想，它是冬天蛰伏的草根，只待一个时机，他将冲破寒冷的缚束，昂扬迎接他的第一缕春晖。</p><h1 id="知足"><a href="#知足" class="headerlink" title="知足"></a>知足</h1><p>理想很丰满，现实很骨感。似乎现实和理想是冲突的？<br>其实不然，理想是我们对明天的憧憬，而知足是我们对我们历史和现状的认可，就像故事中的年轻人，年轻，健康是他目前最大的财富，他应该知足目前的现状，而不能奢求长生。</p><h1 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h1><p>无论对未来充满理想，还是对现状十分满意，我们都需要一个强大的身体。理想是我们生命之树的果实，而身体也是树根虽然不起眼，确实我们在人世间存活的最重要的根基。<br>他是我们最最基础的保障，也是我们对家人，对朋友最大的礼物，所以要锻炼自己，使得自己有个健康的身体。</p><p>爱自己，爱自己，爱自己。重要的事情说三遍</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历了一些事情，让我们增加的不仅仅是我们的知识，更多的是这些事情也在改变我们的心态，如前几日得知我的一位同学身犯重病，我们所有人都在诧异的同时也在反思着，万一是我呢，思虑了几天，总觉得该把这些记录下来，为自己，，也为了自己爱的人，我们是时候来深刻反思自我啦。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://ownwell.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://ownwell.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【Android进阶】Android中使用ProGuard</title>
    <link href="http://ownwell.github.io/2017/10/30/android-better-progurad/"/>
    <id>http://ownwell.github.io/2017/10/30/android-better-progurad/</id>
    <published>2017-10-30T14:08:30.000Z</published>
    <updated>2018-02-26T06:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个有经验的程序员，ProGuard大家一定不陌生，有人说他是混淆，我必须纠正，混淆只是ProGuard的一个过程(我不会称ProGuard为混淆，ProGuard就是ProGuard，谁再说ProGuard才是真正的混淆视听，下面有解释).<br>ProGuard其实不是Android特有的工具，他其实更早适用于java项目中，优化java代码，保证java程序的安全性。由于Android程序大部分也是是Java代码，所以ProGuard成为Android工程师必修的一门课程。<br><a id="more"></a></p><h1 id="简单认识ProGuard"><a href="#简单认识ProGuard" class="headerlink" title="简单认识ProGuard"></a>简单认识ProGuard</h1><p>在平时开发中，我们的项目是ProGuard开关默认是是关的，我们通过如下代码打开ProGuard：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>，  'project.pro'</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>先解释下我们可以通过<code>minifyEnabled</code>打开开关，通过<code>proguardFiles</code>指定我们的<code>ProGuard Rule</code>的多个文件（后面会介绍）。我们也可以使用<code>proguardFile</code>指定一个一个文件，其中<code>proguard-android.txt</code>实际上是我们的<code>{Android Sdk path}/tools/proguard/</code>下<code>proguard-android.txt</code>。这样就可以简单使用我们的ProGuard，当然了对应的<code>ProGuard</code>也是我们SDK下<code>proguard-android.txt</code></p><h1 id="什么是ProGuard"><a href="#什么是ProGuard" class="headerlink" title="什么是ProGuard"></a>什么是ProGuard</h1><p>那个究竟什么是ProGuard呢，我们可以看下<code>{Android Sdk path}/tools/proguard/</code>下的ProGuard的doc文档：</p><blockquote><p>ProGuard is a free Java class file shrinker, optimizer, obfuscator, and preverifier. It detects and removes unused classes, fields, methods, and attributes. It optimizes bytecode and removes unused instructions. It renames the remaining classes, fields, and methods using short meaningless names. Finally, it preverifies the processed code for Java 6 or for Java Micro Edition.</p></blockquote><p>大概意思就是： ProGuard是一个免费的可以将java class文件进行压缩，优化，混淆，预校验的工具。它能删除无用的类，变量、方法以及属性。它能优化字节码，移除无用的指令，同时它将（压缩后）保留的类，变量和方法使用无意义的段字符来重命名，而后还能在对应的java版本上进行预校验这些处理后的code。</p><p>## ProGuard四兄弟</p><p><img src="http://7xwwa2.com1.z0.glb.clouddn.com/proguard_intro.png" alt=""></p><p>如上图，ProGuard实际上四大天王（魔家四将），他们分别是压缩（shrinking），优化（optimization），混淆（obfuscation）和预校验（preverification），一个class和四大天王碰过面才可以到最后的南天门（。</p><p>压缩(shrinking)：检测并移除代码中无用的类、字段、方法和特性（Attribute）<br>优化(optimization)：对字节码进行优化，移除无用的指令<br>混淆(obfuscation)：使用a，b，c，d这样简短而无意义的名称，对类、字段和方法进行重命名<br>预检(preverification)：在Java平台上对处理后的代码进行预检，确保加载的class文件是可执行的。<br>对于一个class文件也要经历如下四步：</p><ol><li>会首先检查这个类是否有地方用到（没用到直接删除），这个类里面的方法或者变量哪些我们没用到，没用到就直接删除</li><li><p>若类没有被删除，检查class文件的无用指令和字节</p></li><li><p>将仍然保留的类，混淆class名及内部的变量和方法名</p></li><li>在对应的java的平台上预校验这个class是否完整有效<br>这个是默认的情况下经历着四个步骤，这个也不是必须的。很像目前中国的大环境，你可以通过人情来避免不必要的麻烦，这四大天王也不例外。<br>例如我写个SDK，里面封装很多java文件，最后类库为第三方服务，最后我打出一个jar，这个jar我期望用混淆。严格按照混淆的四大天王的规则，就会遇到很多问题：</li><li>保留一些类。里面的类好对外使用的，不会被SDK内部使用，按照混淆的四大天王的规则，第一步直接就被干掉了，所有就得走点后门<br>2. 某些class，method或者变量，我期望不要混淆。例如一个支付的class为PaySDK，里面的方法也尽量是aliPay，wxPay，名称有意义，使用混淆后PaySDK成了a，方法名也是无意义的a，b，这对使用sdk的开发者是不友好的。<br>为了避免这个问题，就需要我们自己来制定一个规则，在去南天门的路上，你只管这个规则来给四大天王看，告诉按照我们的规则走，而这个规则就是<code>ProGuard Rule</code>我们刚才配置的<code>proguardFiles</code>,对于我们来说写一个<code>ProGuard Rule</code>是目前比较不太好写的一件事。</li></ol><h1 id="ProGuard-Rule"><a href="#ProGuard-Rule" class="headerlink" title="ProGuard Rule"></a>ProGuard Rule</h1><p>在第一部分我们提到在主项目下的build.gradle配置我们的<code>ProGuard Rule</code>,其中Google官方提供了一个简单的<a href="https://gist.github.com/ownwell/373860e6468671e8e65c8b9eb849f7c2#file-proguard-android-txt" target="_blank" rel="noopener">基础示例</a>：<br>我们就来大致看下他们是分别的作用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># dont 一般是代表do not不要的意思，这个就表示混淆的字符不适用大小写混合的（如Ab）</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br></pre></td></tr></table></figure></p><p>这个是Google建议的，若你非使用大小混合，没人会拦你。😆。<br><br><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 不优化，dex不是运行在JVM上的，当然了也不做预校验</span><br><span class="line">-dontoptimize</span><br><span class="line">-dontpreverify</span><br></pre></td></tr></table></figure><p>这个是针对android的开发而言，不过你要使用优化，尽量使用<code>{Android Sdk path}/tools/proguard/</code>下的<code>proguard-android-optimize.txt</code>文件。<br><br><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注解相关的</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line"># 猜测是Google服务相关的</span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> <span class="title">com</span>.<span class="title">android</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span></span><br></pre></td></tr></table></figure><p>可以看到有个<code>keepattributes</code>肯定是保留类的属性啦，还有个<code>-keep public class 类名</code>这个肯定就是为了保留这个类不被压缩或者混淆。<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclasseswithmembernames <span class="class"><span class="keyword">class</span> * </span>&#123;</span><br><span class="line">    <span class="keyword">native</span> &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个<code>-keepclasseswithmembernames public class 类名</code>不难解释吧，字面意思是保留class和类的成员，并且这个类有个native方法。<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> set*(***);</span><br><span class="line">   *** get*();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个就代表保留类中的getter/setter方法，这个类是继承自<code>android.view.View</code><br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>$* </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;fields&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个肯定是保留我们资源ID对应的R文件中所有的静态变量。<br><br><br></p><p>看了这么多我们会产生疑问：keep、keepclassmembers等这些keep开头的有哪些，区别是什么，怎么配置参数，class，method这些怎么写，*<em>以及</em>分别代表什么，就让我们来一起探索<code>ProGuard Rule</code>的写法吧。</p><h2 id="Keep-options"><a href="#Keep-options" class="headerlink" title="Keep options"></a>Keep options</h2><p>keep目前常见的就6六种：</p><ol><li>-keep [,modifier,…] class_specification </li><li>-keepclassmembers [,modifier,…] class_specification   </li><li>-keepclasseswithmembers [,modifier,…] class_specification </li><li>-keepnames class_specification 在压缩（删除无用的类和成员）后保留下来的类和其成员中，阻止类和类的成员(里面的变量和方法都是成员)混淆</li><li>-keepclassmembernames class_specification 在压缩后保留下来的类中，阻止类的成员被混淆</li><li>-keepclasseswithmembernames class_specification</li></ol><h3 id="有无name的keep"><a href="#有无name的keep" class="headerlink" title="有无name的keep*"></a>有无name的keep*</h3><p>可以看到前三个实际上是比后三个少了name的，但是意义却大不同啊。就以keep和keepName为例吧，<br>keep是阻止类和类的变量（实际上就是类中的方法和变量）被压缩和混淆，而keepnames那么则是在压缩后，防止类和类的成员被混淆。换句话说，keep在压缩第一道大门时，就已经生效，可以避免被压缩掉，即使这个类或者成员没有被用到也不会被移除，而keepnames则是在压缩后，从保留的类中来看哪些类和成员不能被混淆，是在压缩后才生效。<br>官方文档解释的很到位：</p><blockquote><blockquote><blockquote><p>Short for -keep,allowshrinking class_specification</p></blockquote></blockquote></blockquote><p>实际上加了<code>allowshrinking</code>的kepp命令，允许压缩。</p><table><thead><tr><th>关键字</th><th>概述</th></tr></thead><tbody><tr><td>keep</td><td>阻止类和成员被和混淆</td></tr><tr><td>keepclassmember</td><td>阻止类的成员被和混淆</td></tr><tr><td>keepclasseswithmembers</td><td>阻止类和类中特定的成员被压缩和混淆</td></tr><tr><td>keepnames</td><td>在压缩后保留下来的类和其成员中，阻止类和类的成员(里面的变量和方法都是成员)混淆</td></tr><tr><td>keepclassmembernames</td><td>在压缩后保留下来的类和其成员中，阻止类的成员被混淆</td></tr><tr><td>keepclassmembernames</td><td>在压缩后保留下来的类和其成员中，阻止类和类中特定的成员被混淆</td></tr></tbody></table><h3 id="keep-VS-keepclasseswithmembers"><a href="#keep-VS-keepclasseswithmembers" class="headerlink" title="keep VS keepclasseswithmembers"></a>keep VS keepclasseswithmembers</h3><p>这两个都可以注释保留住class及其成员，但是二者区分最大之处在于：keep只看后面的class 是什么，不关心后面的成员，而keepclasseswithmembers则是更关心后面的条件。干说太硬，来点湿的。<br>如下规则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclasseswithmembernames <span class="class"><span class="keyword">class</span> <span class="title">me</span>.<span class="title">cyning</span>.* </span>&#123;</span><br><span class="line">    <span class="keyword">native</span> &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当在me.cyning包下，遇到方法体有native方法时，则keep其class，同时keep这个class的native的方法（其他无用方法可能会被删掉或者方法名会被混淆）。</p><p>而<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">me</span>.<span class="title">cyning</span>.* </span>&#123;</span><br><span class="line">    <span class="keyword">native</span> &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则会将class不压缩</p><p>这个keep*可以保证类或者方法不被压缩和混淆，至于选哪个看你心情喽。</p><p>## </p><h2 id="Class-specifications"><a href="#Class-specifications" class="headerlink" title="Class specifications"></a>Class specifications</h2><p>在刚才示例中，有个代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span></span><br></pre></td></tr></table></figure></p><p>通过这一句<code>keep</code>了<code>com.google.vending.licensing.ILicensingService</code>，但是我们若是<code>keep</code>某一类时而不只是一个class时，我们要怎么办？<br>这就需要我们将这一类的做个抽象，而将这所有的类都列出来一个个keep。</p><p>我们可以来看下class的基本示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">final</span>|<span class="keyword">abstract</span>|@ ...] [!]<span class="class"><span class="keyword">interface</span>|<span class="title">class</span>|<span class="title">enum</span> <span class="title">classname</span></span></span><br><span class="line">    [extends|implements [@annotationtype] classname]</span><br><span class="line">[&#123;</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span>|<span class="keyword">volatile</span>|<span class="keyword">transient</span> ...] &lt;fields&gt; |</span><br><span class="line">                                                                      (fieldtype fieldname);</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span>|<span class="keyword">synchronized</span>|<span class="keyword">native</span>|<span class="keyword">abstract</span>|<span class="keyword">strictfp</span> ...] &lt;methods&gt; |</span><br><span class="line">                                                                                           &lt;init&gt;(argumenttype,...) |</span><br><span class="line">                                                                                           classname(argumenttype,...) |</span><br><span class="line">                                                                                           (<span class="function">returntype <span class="title">methodname</span><span class="params">(argumenttype,...)</span>)</span>;</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span> ... ] *;</span><br><span class="line">    ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>先来解释下[]吧，这个都是可选的，可以选择无，也可以选择[]里的一种或者多种。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@me</span>.cyning.Keep <span class="class"><span class="keyword">class</span> * </span>&#123;</span><br><span class="line">   <span class="keyword">native</span> &lt;methods&gt;() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就表示所有加了<code>me.cyning.Keep</code>类注解且有native方法的类。<br>就让我们分别来看<code>Class specifications</code></p><ol><li>annotationtype实际上就是类注解，如上面<a href="mailto:`@me.cyning.Keep" target="_blank" rel="noopener">`@me.cyning.Keep</a>`</li><li>class/interface/enum 前可以添加修饰符如public，final，abstract等修饰符，也可以在这些修饰符前加!表示否定，如!private 非私有的；在class/interface/enum前也可以加!表示否定，都是黑科技啊</li><li>extends/implements 后可以添加我们继承或者实现的类或者接口，但是记住一定要写全名（包名+classname）。</li><li><fields> 表示里面的变量，他的前面可以加入修饰符<code>public</code>、<code>private</code>、<code>protected</code>、<code>static</code>、<code>volatile</code>、<code>transient</code>等。</fields></li><li><methods>可以表示出了构造函数外的方法，它前面也可以加入<code>public</code>、<code>private</code>、<code>protected</code>、<code>static</code>|<code>synchronized</code>、<code>native</code>、<code>abstract</code>、<code>strictfp</code>等修饰符;而<init>则表示构造函数<br>6.</init></methods></li><li>针对一个class/interface/enum下的所有方法我们可以用<em>来表示如 `public </em>;`则表示所有修饰符为public的方法和变量。</li></ol><p>针对上面的问题，我们还遗漏了一个很重的东西就是通配符，如*，**。而通配符又分为以下：</p><h2 id="packageName-className-methodName"><a href="#packageName-className-methodName" class="headerlink" title="packageName/className/methodName"></a>packageName/className/methodName</h2><p>包名或者类名是我们常见需要用到的，我们列出我们常用的通配符。<br>通配符 |   概述<br>—-    | —<br>？    | 表示任何一个任意但不是包名中的.分隔符。如<code>me.cyning.Test?</code>可以表示<code>me.cyning.Test1</code>和<code>me.cyning.TestA</code>，而不能代表<code>me.cyning.Test11</code></p><ul><li>|  表示任何多个字符但不能是包名中的.分隔符。如<code>me.cyning.Test*</code>可以表示<code>me.cyning.Test1</code>和<code>me.cyning.Test11</code>，而不能代表<code>me.cyning.Test.A</code><br><strong>         | 表示任何多个字符,可以是包名中的.分隔符,如`me.cyning.</strong><code>可以表示</code>me.cyning.Test1<code>和</code>me.cyning.Test11<code>,也可以是</code>me.cyning.Test.A`</li></ul><h2 id="类型描述"><a href="#类型描述" class="headerlink" title="类型描述"></a>类型描述</h2><p>包名或者类名是我们常见需要用到的，我们列出我们常用的通配符。和<code>packageName/className/methodName</code>有类似之处<br>通配符 |   概述<br>—-    | —<br>%  | 除了void的基本类型<br>?  | 单个字符</p><ul><li>| 不包括.包分隔符的任意类名的一部分<br><strong>  | 包括.包分隔符的任意类名的一部分<br>*</strong>  | 任意类型<br>…  | 可表示多个任意且任意类型的类型的参数 如init(…)可代表init(int a, int b) 也可以代表是init(String)<br>熟悉了ProGuard Rule的规则，那么我们再来看最开始我们提到的[默认的ProGuard Rule](—<br>title: android_better_progurad<br>date: 2017-10-30 22:08:30<br>tags:</li></ul><hr><p>过了19大，党有了未来5年的规划，新理念你Get了没？（我觉得开完19大，做地铁都轻松多了，哈哈）。我也给自己裂了个规划，两周一篇博客，越干（gan 一声）越好。今天给自己带来的干货是ProGuard。<br>对于一个有经验的程序员，ProGuard大家一定不陌生，有人说他是混淆，我必须纠正，混淆只是ProGuard的一个过程(我不会称ProGuard为混淆，ProGuard就是ProGuard，谁再说ProGuard才是真正的混淆视听).<br>ProGuard其实不是Android特有的工具，他其实更早适用于java项目中，优化java代码，保证java程序的安全性。由于Android程序大部分也是是Java代码，所以ProGuard成为Android工程师必修的一门课程。</p><h1 id="简单认识ProGuard-1"><a href="#简单认识ProGuard-1" class="headerlink" title="简单认识ProGuard"></a>简单认识ProGuard</h1><p>在平时开发中，我们的项目是ProGuard开关默认是是关的，我们通过如下代码打开ProGuard：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>，  'project.pro'</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>先解释下我们可以通过<code>minifyEnabled</code>打开开关，通过<code>proguardFiles</code>指定我们的<code>ProGuard Rule</code>的多个文件（后面会介绍）。我们也可以使用<code>proguardFile</code>指定一个一个文件，其中<code>proguard-android.txt</code>实际上是我们的<code>{Android Sdk path}/tools/proguard/</code>下<code>proguard-android.txt</code>。这样就可以简单使用我们的ProGuard，当然了对应的<code>ProGuard</code>也是我们SDK下<code>proguard-android.txt</code></p><h1 id="什么是ProGuard-1"><a href="#什么是ProGuard-1" class="headerlink" title="什么是ProGuard"></a>什么是ProGuard</h1><p>那个究竟什么是ProGuard呢，我们可以看下<code>{Android Sdk path}/tools/proguard/</code>下的ProGuard的doc文档：</p><blockquote><p>ProGuard is a free Java class file shrinker, optimizer, obfuscator, and preverifier. It detects and removes unused classes, fields, methods, and attributes. It optimizes bytecode and removes unused instructions. It renames the remaining classes, fields, and methods using short meaningless names. Finally, it preverifies the processed code for Java 6 or for Java Micro Edition.</p></blockquote><p>大概意思就是： ProGuard是一个免费的可以将java class文件进行压缩，优化，混淆，预校验的工具。它能删除无用的类，变量、方法以及属性。它能优化字节码，移除无用的指令，同时它将（压缩后）保留的类，变量和方法使用无意义的段字符来重命名，而后还能在对应的java版本上进行预校验这些处理后的code。<br>## ProGuard四兄弟<br><img src="http://7xwwa2.com1.z0.glb.clouddn.com/proguard_intro.png" alt=""></p><p>如上图，ProGuard实际上四大天王（魔家四将），他们分别是压缩（shrinking），优化（optimization），混淆（obfuscation）和预校验（preverification），一个class和四大天王碰过面才可以到最后的南天门（。</p><p>压缩(shrinking)：检测并移除代码中无用的类、字段、方法和特性（Attribute）<br>优化(optimization)：对字节码进行优化，移除无用的指令<br>混淆(obfuscation)：使用a，b，c，d这样简短而无意义的名称，对类、字段和方法进行重命名<br>预检(preverification)：在Java平台上对处理后的代码进行预检，确保加载的class文件是可执行的。<br>对于一个class文件也要经历如下四步：</p><ol><li>会首先检查这个类是否有地方用到（没用到直接删除），这个类里面的方法或者变量哪些我们没用到，没用到就直接删除</li><li><p>若类没有被删除，检查class文件的无用指令和字节</p></li><li><p>将仍然保留的类，混淆class名及内部的变量和方法名</p></li><li>在对应的java的平台上预校验这个class是否完整有效<br>这个是默认的情况下经历着四个步骤，这个也不是必须的。很像目前中国的大环境，你可以通过人情来避免不必要的麻烦，这四大天王也不例外。<br>例如我写个SDK，里面封装很多java文件，最后类库为第三方服务，最后我打出一个jar，这个jar我期望用混淆。严格按照混淆的四大天王的规则，就会遇到很多问题：</li><li>保留一些类。里面的类好对外使用的，不会被SDK内部使用，按照混淆的四大天王的规则，第一步直接就被干掉了，所有就得走点后门<br>2. 某些class，method或者变量，我期望不要混淆。例如一个支付的class为PaySDK，里面的方法也尽量是aliPay，wxPay，名称有意义，使用混淆后PaySDK成了a，方法名也是无意义的a，b，这对使用sdk的开发者是不友好的。<br>为了避免这个问题，就需要我们自己来制定一个规则，在去南天门的路上，你只管这个规则来给四大天王看，告诉按照我们的规则走，而这个规则就是<code>ProGuard Rule</code>我们刚才配置的<code>proguardFiles</code>,对于我们来说写一个<code>ProGuard Rule</code>是目前比较不太好写的一件事。</li></ol><h1 id="ProGuard-Rule-1"><a href="#ProGuard-Rule-1" class="headerlink" title="ProGuard Rule"></a>ProGuard Rule</h1><p>在第一部分我们提到在主项目下的build.gradle配置我们的<code>ProGuard Rule</code>,其中Google官方提供了一个简单的<a href="https://gist.github.com/ownwell/373860e6468671e8e65c8b9eb849f7c2#file-proguard-android-txt" target="_blank" rel="noopener">基础示例</a>：<br>我们就来大致看下他们是分别的作用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># dont 一般是代表do not不要的意思，这个就表示混淆的字符不适用大小写混合的（如Ab）</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br></pre></td></tr></table></figure></p><p>这个是Google建议的，若你非使用大小混合，没人会拦你。😆。<br><br><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 不优化，dex不是运行在JVM上的，当然了也不做预校验</span><br><span class="line">-dontoptimize</span><br><span class="line">-dontpreverify</span><br></pre></td></tr></table></figure><p>这个是针对android的开发而言，不过你要使用优化，尽量使用<code>{Android Sdk path}/tools/proguard/</code>下的<code>proguard-android-optimize.txt</code>文件。<br><br><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注解相关的</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line"># 猜测是Google服务相关的</span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> <span class="title">com</span>.<span class="title">android</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span></span><br></pre></td></tr></table></figure><p>可以看到有个<code>keepattributes</code>肯定是保留类的属性啦，还有个<code>-keep public class 类名</code>这个肯定就是为了保留这个类不被压缩或者混淆。<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclasseswithmembernames <span class="class"><span class="keyword">class</span> * </span>&#123;</span><br><span class="line">    <span class="keyword">native</span> &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个<code>-keepclasseswithmembernames public class 类名</code>不难解释吧，字面意思是保留class和类的成员，并且这个类有个native方法。<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> set*(***);</span><br><span class="line">   *** get*();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个就代表保留类中的getter/setter方法，这个类是继承自<code>android.view.View</code><br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>$* </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;fields&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个肯定是保留我们资源ID对应的R文件中所有的静态变量。<br><br><br></p><p>看了这么多我们会产生疑问：keep、keepclassmembers等这些keep开头的有哪些，区别是什么，怎么配置参数，class，method这些怎么写，*<em>以及</em>分别代表什么，就让我们来一起探索<code>ProGuard Rule</code>的写法吧。</p><h2 id="Keep-options-1"><a href="#Keep-options-1" class="headerlink" title="Keep options"></a>Keep options</h2><p>keep目前常见的就6六种：</p><ol><li>-keep [,modifier,…] class_specification </li><li>-keepclassmembers [,modifier,…] class_specification   </li><li>-keepclasseswithmembers [,modifier,…] class_specification </li><li>-keepnames class_specification 在压缩（删除无用的类和成员）后保留下来的类和其成员中，阻止类和类的成员(里面的变量和方法都是成员)混淆</li><li>-keepclassmembernames class_specification 在压缩后保留下来的类中，阻止类的成员被混淆</li><li>-keepclasseswithmembernames class_specification</li></ol><h3 id="有无name的keep-1"><a href="#有无name的keep-1" class="headerlink" title="有无name的keep*"></a>有无name的keep*</h3><p>可以看到前三个实际上是比后三个少了name的，但是意义却大不同啊。就以keep和keepName为例吧，<br>keep是阻止类和类的变量（实际上就是类中的方法和变量）被压缩和混淆，而keepnames那么则是在压缩后，防止类和类的成员被混淆。换句话说，keep在压缩第一道大门时，就已经生效，可以避免被压缩掉，即使这个类或者成员没有被用到也不会被移除，而keepnames则是在压缩后，从保留的类中来看哪些类和成员不能被混淆，是在压缩后才生效。<br>官方文档解释的很到位：</p><blockquote><blockquote><blockquote><p>Short for -keep,allowshrinking class_specification</p></blockquote></blockquote></blockquote><p>实际上加了<code>allowshrinking</code>的kepp命令，允许压缩。</p><table><thead><tr><th>关键字</th><th>概述</th></tr></thead><tbody><tr><td>keep</td><td>阻止类和成员被和混淆</td></tr><tr><td>keepclassmember</td><td>阻止类的成员被和混淆</td></tr><tr><td>keepclasseswithmembers</td><td>阻止类和类中特定的成员被压缩和混淆</td></tr><tr><td>keepnames</td><td>在压缩后保留下来的类和其成员中，阻止类和类的成员(里面的变量和方法都是成员)混淆</td></tr><tr><td>keepclassmembernames</td><td>在压缩后保留下来的类和其成员中，阻止类的成员被混淆</td></tr><tr><td>keepclassmembernames</td><td>在压缩后保留下来的类和其成员中，阻止类和类中特定的成员被混淆</td></tr></tbody></table><h3 id="keep-VS-keepclasseswithmembers-1"><a href="#keep-VS-keepclasseswithmembers-1" class="headerlink" title="keep VS keepclasseswithmembers"></a>keep VS keepclasseswithmembers</h3><p>这两个都可以注释保留住class及其成员，但是二者区分最大之处在于：keep只看后面的class 是什么，不关心后面的成员，而keepclasseswithmembers则是更关心后面的条件。干说太硬，来点湿的。<br>如下规则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclasseswithmembernames <span class="class"><span class="keyword">class</span> <span class="title">me</span>.<span class="title">cyning</span>.* </span>&#123;</span><br><span class="line">    <span class="keyword">native</span> &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当在me.cyning包下，遇到方法体有native方法时，则keep其class，同时keep这个class的native的方法（其他无用方法可能会被删掉或者方法名会被混淆）。</p><p>而<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">me</span>.<span class="title">cyning</span>.* </span>&#123;</span><br><span class="line">    <span class="keyword">native</span> &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则会将class不压缩</p><p>这个keep*可以保证类或者方法不被压缩和混淆，至于选哪个看你心情喽。</p><p>## </p><h2 id="Class-specifications-1"><a href="#Class-specifications-1" class="headerlink" title="Class specifications"></a>Class specifications</h2><p>在刚才示例中，有个代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span></span><br></pre></td></tr></table></figure></p><p>通过这一句<code>keep</code>了<code>com.google.vending.licensing.ILicensingService</code>，但是我们若是<code>keep</code>某一类时而不只是一个class时，我们要怎么办？<br>这就需要我们将这一类的做个抽象，而将这所有的类都列出来一个个keep。</p><p>我们可以来看下class的基本示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">final</span>|<span class="keyword">abstract</span>|@ ...] [!]<span class="class"><span class="keyword">interface</span>|<span class="title">class</span>|<span class="title">enum</span> <span class="title">classname</span></span></span><br><span class="line">    [extends|implements [@annotationtype] classname]</span><br><span class="line">[&#123;</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span>|<span class="keyword">volatile</span>|<span class="keyword">transient</span> ...] &lt;fields&gt; |</span><br><span class="line">                                                                      (fieldtype fieldname);</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span>|<span class="keyword">synchronized</span>|<span class="keyword">native</span>|<span class="keyword">abstract</span>|<span class="keyword">strictfp</span> ...] &lt;methods&gt; |</span><br><span class="line">                                                                                           &lt;init&gt;(argumenttype,...) |</span><br><span class="line">                                                                                           classname(argumenttype,...) |</span><br><span class="line">                                                                                           (<span class="function">returntype <span class="title">methodname</span><span class="params">(argumenttype,...)</span>)</span>;</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span> ... ] *;</span><br><span class="line">    ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>先来解释下[]吧，这个都是可选的，可以选择无，也可以选择[]里的一种或者多种。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@me</span>.cyning.Keep <span class="class"><span class="keyword">class</span> * </span>&#123;</span><br><span class="line">   <span class="keyword">native</span> &lt;methods&gt;() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就表示所有加了<code>me.cyning.Keep</code>类注解且有native方法的类。<br>就让我们分别来看<code>Class specifications</code></p><ol><li>annotationtype实际上就是类注解，如上面<a href="mailto:`@me.cyning.Keep" target="_blank" rel="noopener">`@me.cyning.Keep</a>`</li><li>class/interface/enum 前可以添加修饰符如public，final，abstract等修饰符，也可以在这些修饰符前加!表示否定，如!private 非私有的；在class/interface/enum前也可以加!表示否定，都是黑科技啊</li><li>extends/implements 后可以添加我们继承或者实现的类或者接口，但是记住一定要写全名（包名+classname）。</li><li><fields> 表示里面的变量，他的前面可以加入修饰符<code>public</code>、<code>private</code>、<code>protected</code>、<code>static</code>、<code>volatile</code>、<code>transient</code>等。</fields></li><li><methods>可以表示出了构造函数外的方法，它前面也可以加入<code>public</code>、<code>private</code>、<code>protected</code>、<code>static</code>|<code>synchronized</code>、<code>native</code>、<code>abstract</code>、<code>strictfp</code>等修饰符;而<init>则表示构造函数<br>6.</init></methods></li><li>针对一个class/interface/enum下的所有方法我们可以用<em>来表示如 `public </em>;`则表示所有修饰符为public的方法和变量。</li></ol><p>针对上面的问题，我们还遗漏了一个很重的东西就是通配符，如*，**。而通配符又分为以下：</p><h2 id="packageName-className-methodName-1"><a href="#packageName-className-methodName-1" class="headerlink" title="packageName/className/methodName"></a>packageName/className/methodName</h2><p>包名或者类名是我们常见需要用到的，我们列出我们常用的通配符。<br>通配符 |   概述<br>—-    | —<br>？    | 表示任何一个任意但不是包名中的.分隔符。如<code>me.cyning.Test?</code>可以表示<code>me.cyning.Test1</code>和<code>me.cyning.TestA</code>，而不能代表<code>me.cyning.Test11</code></p><ul><li>|  表示任何多个字符但不能是包名中的.分隔符。如<code>me.cyning.Test*</code>可以表示<code>me.cyning.Test1</code>和<code>me.cyning.Test11</code>，而不能代表<code>me.cyning.Test.A</code><br><strong>         | 表示任何多个字符,可以是包名中的.分隔符,如`me.cyning.</strong><code>可以表示</code>me.cyning.Test1<code>和</code>me.cyning.Test11<code>,也可以是</code>me.cyning.Test.A`</li></ul><h2 id="类型描述-1"><a href="#类型描述-1" class="headerlink" title="类型描述"></a>类型描述</h2><p>包名或者类名是我们常见需要用到的，我们列出我们常用的通配符。和<code>packageName/className/methodName</code>有类似之处<br>通配符 |   概述<br>—-    | —<br>%  | 除了void的基本类型<br>?  | 单个字符</p><ul><li>| 不包括.包分隔符的任意类名的一部分<br><strong>  | 包括.包分隔符的任意类名的一部分<br>*</strong>  | 任意类型<br>…  | 可表示多个任意且任意类型的类型的参数 如init(…)可代表init(int a, int b) 也可以代表是init(String)<br>熟悉了ProGuard Rule的规则，那么我们再来看最开始我们提到的<a href="https://gist.github.com/ownwell/373860e6468671e8e65c8b9eb849f7c2#file-proguard-android-txt" target="_blank" rel="noopener">默认的ProGuard Rule</a>。 </li></ul><p>—— 建议读者有时间结合上面介绍的Class specifications和Keep Options，来重新认识和验证下。——–</p><h2 id="自定义ProGuard-Rule"><a href="#自定义ProGuard-Rule" class="headerlink" title="自定义ProGuard Rule)"></a>自定义ProGuard Rule)</h2><p>我们要自定义的ProGuard Rule，其实也是三步走：基本Proguard Rule，业务中常见代码的ProGuard Rule，第三方SDK的ProGuard Rule，一般情况主要按照三步走，尽量做到ProGuard涉及到我们应ProGuard之处。</p><h3 id="基本Proguard-Rule"><a href="#基本Proguard-Rule" class="headerlink" title="基本Proguard Rule"></a>基本Proguard Rule</h3><p>可以直接参考我们的<a href="https://gist.github.com/ownwell/373860e6468671e8e65c8b9eb849f7c2#file-proguard-android-txt" target="_blank" rel="noopener">默认的ProGuard Rule</a>，这个一般不会涉及到业务，也可以在其尾部继续适当加入，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 避免混淆泛型，这在JSON实体映射时非常重要，比如fastJson</span><br><span class="line">-keepattributes Signature</span><br><span class="line"></span><br><span class="line"># 抛出异常时保留代码行号，在异常分析中可以方便定位</span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br><span class="line"></span><br><span class="line"># 抛出异常时保留代码行号，在异常分析中可以方便定位</span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br><span class="line"></span><br><span class="line"># 保留Serializable序列化的类不被混淆</span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.io.ObjectStreamField[] serialPersistentFields;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream)</span></span>;</span><br><span class="line">    java.lang.<span class="function">Object <span class="title">writeReplace</span><span class="params">()</span></span>;</span><br><span class="line">    java.lang.<span class="function">Object <span class="title">readResolve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对于R（资源）下的所有类及其方法，都不能被混淆</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>$* </span>&#123;</span><br><span class="line">    *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个大家是不是基本上是我们最最常见的，不是一定如此，这个是个人观点，仅供参考使用。</p><h3 id="业务常见"><a href="#业务常见" class="headerlink" title="业务常见"></a>业务常见</h3><p>这个需要结合自己的业务来做，或者来看，例如我的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"> 保留实体类和成员不被混淆</span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">entity</span>.** </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> set*(***);</span><br><span class="line">    <span class="keyword">public</span> *** get*();</span><br><span class="line">    <span class="keyword">public</span> *** is*();</span><br><span class="line">&#125;</span><br><span class="line">一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对WebView的处理</span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">webkit</span>.<span class="title">webViewClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> *(android.webkit.WebView, java.lang.String)</span><br><span class="line">&#125;</span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">webkit</span>.<span class="title">webViewClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> *(android.webkit.webView, java.lang.String)</span><br><span class="line">&#125;</span><br><span class="line"># 保留JS方法不被混淆</span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">xxx</span>.<span class="title">MainActivity</span>$<span class="title">JSInterface1</span> </span>&#123;</span><br><span class="line">    &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#  反射中用到的类或者方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 第三方库</span><br><span class="line">一个优秀的开源库，一般会提供我们ProGuard Rule，都说啦是一班啦，二班的同学还是需要根据源代码来自己为开源库添加ProGuard Rule。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.**  </span>&#123; *; &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">interface</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.<span class="title">app</span>.** </span>&#123; *; &#125;</span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.**</span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-<span class="title">dontwarn</span> <span class="title">com</span>.<span class="title">alipay</span>.<span class="title">android</span>.<span class="title">app</span>.**</span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> <span class="title">com</span>.<span class="title">alipay</span>.**  </span>&#123; *; &#125;</span><br></pre></td></tr></table></figure></p><p>网上有雷锋帮我们准备了一份：<a href="https://github.com/msdx/android-proguard-cn" target="_blank" rel="noopener">msdx/android-proguard-cn</a>,拿走不谢。</p><h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>之前看赵四大哥的一篇文章，<a href="http://www.wjdiankong.cn/android%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E4%B9%8B%E6%97%85-%E5%B8%A6%E4%BD%A0%E6%8A%8Aapk%E6%B7%B7%E6%B7%86%E6%88%90%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81/" target="_blank" rel="noopener">Android安全防护之旅—带你把Apk混淆成中文语言代码</a>,它从源码上做了处理，不过这个不是我期望的，后来居然发现，ProGuard居然真的可以设置mappding的字典：<br>-obfuscationdictionary naruto.txt<br>naruto已经上传到<a href="https://gist.github.com/ownwell/2dc6486b4cdda3ab556859c1d63045d3" target="_blank" rel="noopener">gitgist</a>啦.<br>打开有惊喜哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个有经验的程序员，ProGuard大家一定不陌生，有人说他是混淆，我必须纠正，混淆只是ProGuard的一个过程(我不会称ProGuard为混淆，ProGuard就是ProGuard，谁再说ProGuard才是真正的混淆视听，下面有解释).&lt;br&gt;ProGuard其实不是Android特有的工具，他其实更早适用于java项目中，优化java代码，保证java程序的安全性。由于Android程序大部分也是是Java代码，所以ProGuard成为Android工程师必修的一门课程。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="Android进阶" scheme="http://ownwell.github.io/tags/Android%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【Android进阶】Android的APK两种签名</title>
    <link href="http://ownwell.github.io/2017/10/13/apk-two-signer/"/>
    <id>http://ownwell.github.io/2017/10/13/apk-two-signer/</id>
    <published>2017-10-12T16:24:48.000Z</published>
    <updated>2018-02-26T06:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在研究APK瘦身的相关知识，发现有个很有意思的知识点就是apk的签名 – APK Signature Scheme v2，虽然出来了一段时间，但是这方便真是没做太多的关注，趁着十一刚过的热乎劲撸起袖子干一波。<br><a id="more"></a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>目前为止，android通用的打包过程时使用的签名工具有两套–jarsigner和apksigner。其中apksigner也就是刚才我们提到的APK Signature Scheme v2，两者有什么关系，为什么要使用新的签名机制呢？这是我们这篇文章介绍的重点。</p><p>在了解签名之前我们需要了解几个知识点：</p><ul><li>数字签名</li><li>ZipAlign</li><li>keystore</li></ul><h2 id="数字签名-–-Signature"><a href="#数字签名-–-Signature" class="headerlink" title="数字签名 – Signature"></a>数字签名 – Signature</h2><ul><li>数字签名就是信息的发送者用自己的私钥对消息摘要加密产生一个字符串，加密算法确保别人无法伪造生成这段字符串，这段数字串也是对信息的发送者发送信息真实性的一个有效证明。</li><li>数字签名是 非对称密钥加密技术 + 数字摘要技术 的结合。</li><li>数字签名技术是将信息摘要用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的信息摘要，然后接收者用相同的Hash函数对收到的原文产生一个信息摘要，与解密的信息摘要做比对。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改；不同则说明信息被修改过，因此数字签名能保证信息的完整性。并且由于只有发送者才有加密摘要的私钥，所以我们可以确定信息一定是发送者发送的。<br>我们的APK就是通过这种数字签名技术保证我们APK的安全。</li></ul><h2 id="ZipAlign"><a href="#ZipAlign" class="headerlink" title="ZipAlign"></a>ZipAlign</h2><p>zip对齐，因为APK包的本质是一个zip压缩文档，经过边界对齐方式优化能使包内未压缩的数据有序的排列，从而减少应用程序运行时的内存消耗 ，通过空间换时间的方式提高执行效率（zipalign后的apk包体积增大了90KB左右）。</p><p>切换目录到SDK的build-tools目录下（例如 SDK/build-tools/25.0.2/），执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zipalign -v <span class="number">4</span> infile.apk outfile.apk</span><br></pre></td></tr></table></figure></p><h2 id="keystore"><a href="#keystore" class="headerlink" title="keystore"></a>keystore</h2><p> keystore是我们打包过程中必须要填写的内容，这个类似我们代表我们开发者信息的一个『证书』，这个证书类似开发者的”身份证”,它是唯一的，所以只要一个app有这个证书，在应用市场上就可以保证这个app不会被别人冒充，也可以作为一个开发者的凭证（只要keystore的密码账号不被泄露）。<br> 具体内容可以参考：<a href="http://www.jianshu.com/p/644ddb6e3d9c" target="_blank" rel="noopener">Android Keystore漫谈</a>.<br> 我们可以通过jdk/bin/下的keytool工具来创建自己的keystore：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -alias &quot;cyning&quot; -keyalg &quot;RSA&quot; -keystore &quot;cyningfile.keystore&quot;</span><br></pre></td></tr></table></figure><p>创建一个别名为cyning的证书，该证书存放在名为cyningfile.keystore的密钥库中，若cyningfile.keystore密钥库不存在则创建。<br>现在更多人是通过Android Studio的工具来创建自己的keystore。</p><p>参数说明：</p><p>-genkeypair：生成一对非对称密钥;<br>-alias：指定密钥对的别名，该别名是公开的;<br>-keyalg：指定加密算法，本例中的采用通用的RAS加密算法;<br>-keystore:密钥库的路径及名称，不指定的话，默认在操作系统的用户目录下生成一个”.keystore”的文件</p><p>查看这个keystore：<br>keytool -list -keystore cyningfile.keystore</p><h1 id="APK的签名"><a href="#APK的签名" class="headerlink" title="APK的签名"></a>APK的签名</h1><p>在V2签名出来之前我们都是通过<code>jarsigner</code>签名，而后才有<code>APK Signature Scheme v2</code>.他们有很大的不同。</p><h2 id="META-INF下签名三兄弟"><a href="#META-INF下签名三兄弟" class="headerlink" title="META-INF下签名三兄弟"></a>META-INF下签名三兄弟</h2><p>所谓签名三兄弟，实际上就是META-INF文件夹下的MANIFEST.MF、CERT.SF、CERT.RSA三个文件。<br>它会先通过SHA1算法生成这些文件（png，dex等）的信息摘要，而后会生产MANIFEST.MF。</p><h1 id="jarsigner"><a href="#jarsigner" class="headerlink" title="jarsigner"></a>jarsigner</h1><p>jarsigner是由JDK提供的一个签名工具，JDK/bin/jarsigner(jarsigner，windows上是exe文件).<br>通过这个工具也可以给我们的APK进行签名，在<code>APK Signature Scheme v2</code>出来之前都是采用这种方式。<br>我们可以使用如下命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -keystore test.keystore -signedjar -signed.apk unsigned.apk <span class="string">'test.keystore'</span></span><br></pre></td></tr></table></figure></p><p>对照签名前后，META-INFO文件的变化：</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/10/a86b4f21d90cbf54c181caf6bcbfd860" alt="签名前"><br><img src="https://user-gold-cdn.xitu.io/2017/10/10/8c2f51b4135469231ec206fb8a724128" alt="签名后"></p><p>就会发现签名后多了两个文件CERT.SF、CERT.RSA，同时MANIFEST.MF会多了文件和对应的SHA1算法下的摘要。<br>MF实际上会列出文件解压后的所有文件除了META-INF下所有文件的签名。<br>SF则是MF文件的摘要信息以及.MF文件当中每个条目在用摘要算法计算得到的摘要信息并用base64编码保存；CERT.SF文件则存放证书信息，公钥信息，以及用私钥对.SF文件的加密数据即签名信息，这样保证了每个文件的完整性，但都是基于apk解压后的所有文件。</p><p>在安装APK时，会先检查CERT.SF文件，确认签名正确，而后检查SF文件，再通过SF去检查apk文件下各个文件，这样一步步环环相扣确保了每个文件都是有效的，确保了文件的完整和安全性，但是对于好事者还是发现了其中的漏洞，美团有个方案就是通过在META-INF下添加一个空文件来代表渠道，这个空文件不会被检查，他和任何文件没有关联（CERT.SF、CERT.RSA和MANIFEST.MF他们是相关关联的）。</p><p>这样是没有问题的，什么对于apk文件ZipAlign处理后他们的压缩产物是一致的，所以在安装apk时，也是可以通过，但是这样真的安全么？<br>答案是否！<br>我们可以通过这些不检测文件中存放不安全的代码，同时每次安装apk都需要解压apk文件来进行校验，耗时，也是个耗电的过程。</p><p>于是乎，在Android Build Tools从24.0.3版本引入的一个新的apk文件签名工具apksigner，也就是google官网上说的<br><a href="https://source.android.com/security/apksigning/v2" target="_blank" rel="noopener"><code>Signature Scheme v2</code>翻译过来过来就是APK签名方案v2</a>.</p><h1 id="apksigner"><a href="#apksigner" class="headerlink" title="apksigner"></a>apksigner</h1><p>apksigner是基于真个apk二进制文件进行校验的，即使你使用了ZipAlign对齐后，二进制文件发生了改变，就认为两个apk不一样,实际上也就是两个不同的文件。<br>官方解释是在apk文件的Central Directory前面插入了一个apk签名块用来存放apk的签名信息，来确保apk签名的安全性，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/12/dd03318efe8ad982b36db9e8d8516644" alt=""></p><p>这样apk就等于是是有了四块：<br><img src="https://user-gold-cdn.xitu.io/2017/10/12/2bfa5ef2448e40a17f54fcf19db4e489" alt=""></p><blockquote><p>google建议： APK 签名方案 v2 是在 Android 7.0 (Nougat) 中引入的。为了使 APK 可在 Android 6.0 (Marshmallow) 及更低版本的设备上安装，应先使用 JAR 签名功能对 APK 进行签名，然后再使用 v2 方案对其进行签名。<br>在android studio的Gradle Plugin 2.2以及之上版本的插件当中，默认是v2开启的,需要的话可以自定义关或者开：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signConfig &#123;</span><br><span class="line">    v1SigningEnabled <span class="keyword">false</span></span><br><span class="line">    v2SigningEnabled <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>其中apk签名块也是个的结构如下：<br><img src="https://user-gold-cdn.xitu.io/2017/10/12/6127028bd1d01f848712035120ff9855" alt="apk签名块"><br>美团又一次利用了规则，在ID-Value的加入一个渠道ID-Value(apk不会校验id，value的有效性)。<br>其文章思路参考：<a href="https://tech.meituan.com/android-apk-v2-signature-scheme.html" target="_blank" rel="noopener">新一代开源Android渠道包生成工具Walle</a>.</p><p>所以，和jarsign相比，apksign签名更安全，其打包生成的apk也更小,赶快动手试试吧。<br>使用么就很简单啦：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign --ks keystore.jks |</span><br><span class="line">  --key key.pk8 --cert cert.x509.pem</span><br><span class="line">  [signer_options] app-name.apk</span><br></pre></td></tr></table></figure></p><p>更多工具可以参考<a href="https://developer.android.com/studio/command-line/apksigner.html" target="_blank" rel="noopener">谷歌官方文档</a>.<br>总结下：jarsigner签名是jdk提供的签名工具，它是针对apk文件压缩后的文件进行的完整和安全性校验，而apksign也是通过对apk二进制文件的校验，也更安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在研究APK瘦身的相关知识，发现有个很有意思的知识点就是apk的签名 – APK Signature Scheme v2，虽然出来了一段时间，但是这方便真是没做太多的关注，趁着十一刚过的热乎劲撸起袖子干一波。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="Android进阶" scheme="http://ownwell.github.io/tags/Android%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>注解（2）-- 定义自己的Annotation Processor</title>
    <link href="http://ownwell.github.io/2017/08/17/annotation-for-andrroid-2/"/>
    <id>http://ownwell.github.io/2017/08/17/annotation-for-andrroid-2/</id>
    <published>2017-08-17T13:15:58.000Z</published>
    <updated>2018-02-27T07:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家还记得<code>[JakeWharton](https://github.com/JakeWharton)</code>写的翻遍ui注解的库<code>butterknife</code>么？<br>之前我们都是使用findviewById来查找view，有了<code>butterknife</code>我们摆脱了这种重复代码，通过注解我们解放了生产力，我们可以把更多的经理放到我们的业务和整体的架构上来，而不是不断重复的代码。<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/201802091588.png-blog" alt=""><br><a id="more"></a><br>在开始前我们需要了解一下<code>Annotation Processor</code>，使用 Annotation Processor 来自动生成可以提高编写代码的效率和质量，手工编写毕竟容易出现纰漏，工具自动生成是有质量保证的。Annotation Processor 主要涉及 3 部分，注解本身（Annotation）、注解处理器（Annotation Processor）以及 如何使用注解器。</p><h1 id="一、Hello-world"><a href="#一、Hello-world" class="headerlink" title="一、Hello world"></a>一、Hello world</h1><p>万事先从一个HelloWorld开始，我们可以通过<code>Annotation Processor</code>来自己生成一个类，这个类中的main方法可以打印hello world。</p><h2 id="1-声明注解"><a href="#1-声明注解" class="headerlink" title="1. 声明注解"></a>1. 声明注解</h2><p>需要我们通过Android Studio来新建一个java lib项目 helloAnotation。<br>其中需要声明一个注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HelloWorld &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">version</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Annotation-Processor"><a href="#2-Annotation-Processor" class="headerlink" title="2. Annotation Processor"></a>2. Annotation Processor</h2><p>再来一个java lib项目我们给它起名字为<code>helloAnotation</code>，这个库中的核心是一个需要继承<code>AbstractProcessor</code>的类，为了快捷实现这个类我们还需要借助<code>javapoet</code>这个工具包。</p><p>后面会详细介绍<code>AbstractProcessor</code>和<code>javapoet</code>，我们先来自己定义一个Processor类。<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/5C6689ADF977FB09DD3B60ADFD839FF.png" alt=""></p><h3 id="Processor类"><a href="#Processor类" class="headerlink" title="Processor类"></a>Processor类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWord</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(<span class="keyword">void</span>.class)</span><br><span class="line">                .addParameter(String[].class, <span class="string">"args"</span>)</span><br><span class="line">                .addStatement(<span class="string">"$T.out.println($S)"</span>, System.class, <span class="string">"Hello, World! "</span> )</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorldC"</span>)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(main)</span><br><span class="line">                .build();</span><br><span class="line">        JavaFile javaFile = JavaFile.builder(<span class="string">"com.example.helloworld"</span>, helloWorld)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaFile.writeTo(processingEnv.getFiler());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明processor类"><a href="#声明processor类" class="headerlink" title="声明processor类"></a>声明processor类</h3><p>如今已经编写完毕了 processor，需要告知系统，我们创建/<code>src/main/resources/META-INF/services</code>文件夹，同时在这个文件夹下创建<code>javax.annotation.processing.Processor</code>文件，在这个文件下，写入我们的processor的完全路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">me.cyning.anotationcore.HelloWord</span><br></pre></td></tr></table></figure><p>整个<code>helloAnotation</code>库的<code>build.gradle</code>需要配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup:javapoet:1.7.0'</span></span><br><span class="line">implementation <span class="string">'com.google.guava:guava:23.3-android</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在主项目的入口类TestActivity的类使用这个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HelloWorld</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span></span><br></pre></td></tr></table></figure><p>build.gradle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">annotationProcessor <span class="title">project</span><span class="params">(<span class="string">':AnotationCompiler'</span>)</span></span></span><br><span class="line"><span class="function">implementation <span class="title">project</span><span class="params">(<span class="string">': helloAnotation'</span>)</span></span></span><br></pre></td></tr></table></figure><p>再次编译就可以在你的主项目的build/generated/source/apt/debug下看到我们生成的类。<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/d90d56a0fadfdc05505e5d34474e7159.png" alt=""></p><h1 id="理解Annotation-Processor"><a href="#理解Annotation-Processor" class="headerlink" title="理解Annotation Processor"></a>理解Annotation Processor</h1><p>在这个<code>helloWorld</code>的 🌰  中，我们需要掌握两个知识点：<code>AbstractProcessor</code>和<code>javapoet</code>.</p><h2 id="AbstractProcessor"><a href="#AbstractProcessor" class="headerlink" title="AbstractProcessor"></a>AbstractProcessor</h2><h3 id="AbstractProcessor-函数实现"><a href="#AbstractProcessor-函数实现" class="headerlink" title="AbstractProcessor 函数实现"></a>AbstractProcessor 函数实现</h3><p><code>AbstractProcessor</code>是自定义<code>Annotation Processor</code>核心，它是运行在我们的编译代码阶段，也就是说我们每次在编译前，我们的编译器会根据我们实现的<code>AbstractProcessor</code>类来生成相关类。<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/5a4a5f5683d9ef3e.png" alt=""></p><p><code>AbstractProcessor</code>是个抽象类，有几个函数使我们必须要实现的。</p><ol><li>init(ProcessingEnvironment processingEnvironment) 这个可以认为是初始化工作，通过<code>processingEnvironment</code>我们可以得到很多有用的工具类，如Elements,Types和Filer，这个后面我们是会接触到的。</li><li><code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code>: 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数<code>RoundEnviroment</code>，可以让你查询出包含特定注解的被注解元素。后面我们将看到详细的内容。</li><li><code>getSupportedAnnotationTypes</code>  是给那些注解使用的，因为可能一个项目中有多个注解器，所有这个是检查步骤，只有在<code>getSupportedAnnotationTypes</code>中就可以继续执行下面的操作。如刚才的helloworld项目中的<code>HelloWorld</code>注解,需要我们声明下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.singleton(<span class="string">"me.cyning.anotationan.HelloWorld"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>getSupportedSourceVersion</code> 指定java版本。通常我们设置为：SourceVersion.latestSupported()，当然你可以自己指定，如指定java 7 SourceVersion.RELEASE_7.</li></ol><blockquote><p>在java 7 之后呢，我们可以通过注解来实现对<code>getSupportedAnnotationTypes</code>和<code>getSupportedSourceVersion</code> 配置。</p><p>@SupportedSourceVersion(SourceVersion.RELEASE_7)<br>@SupportedAnnotationTypes({“me.cyning.anotationan.HelloWorld”})<br>public class HelloWord extends AbstractProcessor{<br>……<br>}</p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>由于实现自定义的<code>AbstractProcessor</code>需要借助<code>javax.annotation.processing</code>等jdk的工具包的类，有几个变量和工具类可能是需要了解的。</p><ol><li><code>Element</code>.在获取我们的注解变量时，我们需要根据我们的实际情况来判断，如这个变量是方法，类或者包时，需要借助如下几个类：<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/4d8b64798c909ea083157d59d9fe77b0.png" alt=""></li></ol><p>Element代表java源文件中的程序构建元素，例如包、类、方法等。</p><ol start="2"><li><code>TypeMirror</code>: <code>TypeMirror</code>用来描述类信息，如判断类继承关系等。<br>通过Element.asType()接口可以获取Element的TypeMirror。</li></ol><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/aac48d97892865f4e111cfa0b8741f10.png" alt=""></p><p>当TypeMirror是DeclaredType或者TypeVariable时，TypeMirror可以转化成Element:<br><code>Element element = processingEviroment.getTypeUtils().asElement(typeMirror);</code></p><ol start="3"><li><p>工具类：有几个工具类对我们的开发很有用。</p><p><code>Log</code><br> 通过 init方法中获取Messager()对象，<code>messager = processingEnv.getMessager()</code>，在需要打日志的地方打印只需要            <code>messager.printMessage(Diagnostic.Kind.NOTE, logStr)</code></p><p><code>通过string获取TypeMirror</code><br> 如需要获得<code>android.view.View</code>对应的<code>TypeMirror</code>,只需要在init方法中加入如下代码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elementUtils = processingEnv.getElementUtils();</span><br><span class="line">mIViewBindType =   elementUtils.getTypeElement(``android.view.View``).asType();</span><br></pre></td></tr></table></figure><h2 id="javapoet"><a href="#javapoet" class="headerlink" title="javapoet"></a><code>javapoet</code></h2><p><code>javapoet</code>是square公司开源的一个可以生产java文件的库，在Github上的地址：<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">square/javapoet</a>.他是一个很好的工具，有个它，会让你事半功倍。<br>如在刚才例子中生产的一个类的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">        .returns(<span class="keyword">void</span>.class)</span><br><span class="line">        .addParameter(String[].class, <span class="string">"args"</span>)</span><br><span class="line">        .addStatement(<span class="string">"$T.out.println($S)"</span>, System.class, <span class="string">"Hello, World! "</span> )</span><br><span class="line">        .build();</span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorldC"</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">        .addMethod(main)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p> 只需要添加修饰符（<code>addModifiers</code>）、传参（<code>addParameter</code>）、添加代码块（<code>addStatement</code>）这样一个方法搞定，至于类的生成似乎更简单。<br>这样优雅的写法，有没有电到你。</p><h1 id="仿ButterKnife"><a href="#仿ButterKnife" class="headerlink" title="仿ButterKnife"></a>仿ButterKnife</h1><p>在仿butterknife之前我们可以先预习下我们自定义<code>Annotation Processor</code> 的三部曲：</p><blockquote><ol><li>自定义注解</li><li>实现Processor类，将这个<code>Processor</code>类放到到<code>resources/META-INF</code>下指定的文件（一个<code>Processor</code>类一行，多个需要写多行）</li><li>写我们的入口类，如butterKnife的<code>ButterKnife.bind(Activity activity)</code></li></ol></blockquote><p><strong>目的</strong>： <code>仿ButterKnife</code>学习写自己的注解库， 期望结果，我们写如下类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span>(R.id.btnTest)</span><br><span class="line">    <span class="keyword">public</span> Button btnTest;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span>(R.id.btnTest2)</span><br><span class="line">    <span class="keyword">public</span> Button btnTes2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        DroidFinder.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        btnTes2.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        btnTest.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, v.getId() +<span class="string">" "</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>能通过<code>DroidFinder.bind(this)</code>这个入口和 <code>Inject</code>生成的类，自己去实现哪些findViewById这个重复代码。</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>由于我们是类中的变量来注解，所以可以直接使用<code>FIELD</code>,而注解 <code>Inject</code>后的value是view的id为整形，所以可以自定义注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解需要放到一个单独的java lib下，我们命名为<code>inject-anotation</code>.</p><h2 id="实现Processor类"><a href="#实现Processor类" class="headerlink" title="实现Processor类"></a>实现Processor类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">mport com.google.auto.service.AutoService;</span><br><span class="line"><span class="keyword">import</span> com.squareup.javapoet.JavaFile;</span><br><span class="line"><span class="keyword">import</span> com.squareup.javapoet.MethodSpec;</span><br><span class="line"><span class="keyword">import</span> com.squareup.javapoet.TypeName;</span><br><span class="line"><span class="keyword">import</span> com.squareup.javapoet.TypeSpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.AbstractProcessor;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.Processor;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.RoundEnvironment;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.SupportedAnnotationTypes;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.SupportedSourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Modifier;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.PackageElement;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.VariableElement;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.type.TypeMirror;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.Elements;</span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> me.cyning.anotationan.Inject;</span><br><span class="line"><span class="keyword">import</span> me.cyning.anotationcore.inter.ClassTarget;</span><br><span class="line"><span class="keyword">import</span> me.cyning.anotationcore.inter.FieldTarget;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"me.cyning.anotationan.Inject"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ProcessingEnvironment mProEnv;</span><br><span class="line">    Messager messager = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUFFIX = <span class="string">"_Binder"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BINDER_INTERFACE = <span class="string">"me.cyning.core.bind.IViewBind"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TypeMirror mIViewBindType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Elements elementUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        mProEnv = processingEnv;</span><br><span class="line"></span><br><span class="line">        messager = processingEnv.getMessager();</span><br><span class="line"></span><br><span class="line">        elementUtils = processingEnv.getElementUtils();</span><br><span class="line">        mIViewBindType = elementUtils.getTypeElement(BINDER_INTERFACE).asType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;TypeElement, ClassTarget&gt; mTargetMaps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String packageStr = <span class="keyword">null</span>;</span><br><span class="line">        String classNameStr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TypeElement classElem = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Set&lt;Element&gt; mElements = (Set&lt;Element&gt;) roundEnv.getElementsAnnotatedWith(Inject.class);</span><br><span class="line">        <span class="keyword">for</span> (Element mElement : mElements) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ElementType.FIELD注解可以直接强转VariableElement</span></span><br><span class="line">            VariableElement variableElement = (VariableElement) mElement;</span><br><span class="line">            classElem = (TypeElement) variableElement.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">            String name = variableElement.getSimpleName().toString();</span><br><span class="line">            <span class="comment">// 获取Inject跟的view的id</span></span><br><span class="line">            <span class="keyword">int</span> id = variableElement.getAnnotation(Inject.class).value();</span><br><span class="line">            TypeMirror type = variableElement.asType();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            PackageElement pkgElem = mProEnv.getElementUtils().getPackageOf(classElem);</span><br><span class="line">            packageStr = pkgElem.getQualifiedName().toString();</span><br><span class="line">            classNameStr = classElem.getSimpleName().toString() + SUFFIX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ClassTarget mClassTarget = mTargetMaps.get(classElem);</span><br><span class="line">            <span class="keyword">if</span> (mClassTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mClassTarget = <span class="keyword">new</span> ClassTarget();</span><br><span class="line">                mClassTarget.clazzName = classNameStr;</span><br><span class="line">                mClassTarget.packageName = packageStr;</span><br><span class="line">                mClassTarget.classType = classElem.asType();</span><br><span class="line">                mTargetMaps.put(classElem, mClassTarget);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            FieldTarget fieldTarget = <span class="keyword">new</span> FieldTarget();</span><br><span class="line">            fieldTarget.id = id;</span><br><span class="line">            fieldTarget.name = name;</span><br><span class="line">            fieldTarget.type = type;</span><br><span class="line">            mClassTarget.add(fieldTarget);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            log(<span class="string">"getEnclosingElement"</span>, classElem.getEnclosingElement().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log(<span class="string">"getEnclosingElement"</span>, <span class="string">'1'</span>);</span><br><span class="line">        log(<span class="string">"classNameStr "</span>, classNameStr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classNameStr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Iterator entries = mTargetMaps.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                    Map.Entry&lt;TypeElement, ClassTarget&gt; entry = (Map.Entry&lt;TypeElement, ClassTarget&gt;) entries.next();</span><br><span class="line"></span><br><span class="line">                    TypeElement key = (TypeElement) entry.getKey();</span><br><span class="line"></span><br><span class="line">                    ClassTarget value = (ClassTarget) entry.getValue();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    MethodSpec.Builder builder = MethodSpec.methodBuilder(<span class="string">"findViews"</span>)</span><br><span class="line">                            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                            .addAnnotation(Override.class)</span><br><span class="line">                            .addParameter(Object.class, <span class="string">"obj"</span>, Modifier.FINAL)</span><br><span class="line">                            .returns(<span class="keyword">void</span>.class)</span><br><span class="line">                            .addStatement(<span class="string">"$T target = (($T) obj)"</span>, value.classType, value.classType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (FieldTarget mFieldTarget : value.mFieldTargets) &#123;</span><br><span class="line">                        builder.addStatement(<span class="string">"target."</span> + mFieldTarget.name + <span class="string">" = "</span> + <span class="string">"($T)target.findViewById("</span> + mFieldTarget.id + <span class="string">")"</span>, mFieldTarget.type);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    MethodSpec flux = MethodSpec.constructorBuilder()</span><br><span class="line">                            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    MethodSpec findViews = builder</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    TypeSpec bindClazz = TypeSpec.classBuilder(value.clazzName)</span><br><span class="line">                            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                            .addMethod(findViews)</span><br><span class="line">                            .addMethod(flux)</span><br><span class="line">                            .addSuperinterface(TypeName.get(mIViewBindType))</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">                    JavaFile javaFile = JavaFile.builder(value.packageName, bindClazz)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">                    javaFile.writeTo(processingEnv.getFiler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String tag, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.NOTE, tag + <span class="string">" --- "</span> + object.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家还记得&lt;code&gt;[JakeWharton](https://github.com/JakeWharton)&lt;/code&gt;写的翻遍ui注解的库&lt;code&gt;butterknife&lt;/code&gt;么？&lt;br&gt;之前我们都是使用findviewById来查找view，有了&lt;code&gt;butterknife&lt;/code&gt;我们摆脱了这种重复代码，通过注解我们解放了生产力，我们可以把更多的经理放到我们的业务和整体的架构上来，而不是不断重复的代码。&lt;br&gt;&lt;img src=&quot;http://7xj9f0.com1.z0.glb.clouddn.com/201802091588.png-blog&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="Android进阶" scheme="http://ownwell.github.io/tags/Android%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>注解（1）-- 什么是注解</title>
    <link href="http://ownwell.github.io/2017/08/08/annotation-for-andrroid-one/"/>
    <id>http://ownwell.github.io/2017/08/08/annotation-for-andrroid-one/</id>
    <published>2017-08-08T13:58:07.000Z</published>
    <updated>2018-02-27T06:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个Android程序员，注解（Annotation）会是一个让我们事半功倍的一个开发利器，它可以简化代码（如ButterKnife），可以约束输入条件（如support-annotations），可以将输入条件改为配置（如Retrofit 2.0）等，就让我们开下注解在注解在Android开发中是怎么使用。</p><p><img src="http://7xj9f0.com1.z0.glb.clouddn.com/%E6%B3%A8%E8%A7%A3.png-blog" alt=""><br><a id="more"></a></p><p>为了容易让大家理解什么是注解，文章会分为分为以下两篇来分别介绍：</p><ul><li>注解的基本概念以及自定义注解</li><li>定义自己的Annotation Processor</li><li>模仿ButterKnife</li></ul><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>今天我们的任务是自定义一个注解，并在运行时获取到它的值。</p><p>— 代码1：—<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.btnTest)</span><br><span class="line">    Button btnTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>Java1.5引入了注解，当前许多框架中大量使用注解，如Spring。我们可以自己定义注解来， 这些注解会在编译过程或执行时产生作用。</p><p>如上面的代码中<code>@BindView</code>就是一个自定义的注解，我么需要在使用前先声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先BindView这不是一个接口，因为它的声明是<code>@interface</code>,其次它的定义需要用到<code>Retention</code>和<code>Target</code>这两个元注解。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：</p><ul><li>@Target,</li><li>@Retention,</li><li>@Documented,</li><li>@Inherited</li></ul><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>@Target主要是描述注解的范围，如包，类，变量等，像代码1中的BindView是声明在变量上，下面是target常用的几个：</p><ol><li>CONSTRUCTOR:用于描述构造器</li><li>FIELD:用于描述域</li><li>LOCAL_VARIABLE:用于描述局部变量</li><li>METHOD:用于描述方法</li><li>PACKAGE:用于描述包</li><li>PARAMETER:用于描述参数</li><li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li></ol><h3 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h3><p>Retention代表它什么时候发生作用，常用就三种：</p><ol><li>SOURCE:在源文件中有效（即源文件保留）</li><li>CLASS:在class文件中有效（即class保留）</li><li>RUNTIME:在运行时有效（即运行时保留）</li></ol><h1 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h1><p>主要是javadoc档案化需要</p><h1 id="Inherited："><a href="#Inherited：" class="headerlink" title="@Inherited："></a>@Inherited：</h1><p>@Inherited阐述了某个被标注的类型是被继承的</p><h1 id="验证自定义的情况"><a href="#验证自定义的情况" class="headerlink" title="验证自定义的情况"></a>验证自定义的情况</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"btn id : "</span> + R.id.btnTest );</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        Field[] fields  =  <span class="keyword">this</span>.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(BindView.class)) &#123;</span><br><span class="line">                BindView bindView = field.getAnnotation(BindView.class);</span><br><span class="line">                <span class="keyword">int</span> viewID = bindView.value();</span><br><span class="line">                Log.e(TAG, <span class="string">"processAnnotation: "</span> + viewID );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现打印的两个值是相等的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个Android程序员，注解（Annotation）会是一个让我们事半功倍的一个开发利器，它可以简化代码（如ButterKnife），可以约束输入条件（如support-annotations），可以将输入条件改为配置（如Retrofit 2.0）等，就让我们开下注解在注解在Android开发中是怎么使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj9f0.com1.z0.glb.clouddn.com/%E6%B3%A8%E8%A7%A3.png-blog&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="注解" scheme="http://ownwell.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【Android进阶】Android动态加载so文件</title>
    <link href="http://ownwell.github.io/2017/07/18/dynamic-load-so/"/>
    <id>http://ownwell.github.io/2017/07/18/dynamic-load-so/</id>
    <published>2017-07-17T16:29:19.000Z</published>
    <updated>2017-12-04T15:13:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务的增大，我们的业务代码也随之增多，包的大小是有增无减，所以适当的时候思考下:怎么做减法–减小包的体积。</p><p>结合最近在做的公司的项目，觉得动态加载so文件是一个很好精简apk包的方法。举个例子，视频播放器的SDK（如IJKplayer，VLC player），他们的各种视频的解码器一般都是通过C/C++编译的so文件，这些so文件其实都不小，这样导致我们从市场上下载的apk包很大，所以能不能让so文件不随apk一起发布呢，而是按需下载(只有当需要播放视频时才去服务器下载，然后再在本地load)。<br><a id="more"></a><br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/so-fix.png" alt=""></p><h1 id="为什么要动态加载"><a href="#为什么要动态加载" class="headerlink" title="为什么要动态加载"></a>为什么要动态加载</h1><p>其实刚才已经解释了，可以有效避免apk安装包过大，因为这些so文件是依赖server的下发，本地只是load的过程。<br>其次，动态加载可以动态升级so文件，也是动态化的一部分。可以在不发版的情况下，升级so文件。</p><blockquote><p>动态加载so文件，必须进行安全性校验，避免不必要的安全事故。</p></blockquote><h1 id="动态加载so文件"><a href="#动态加载so文件" class="headerlink" title="动态加载so文件"></a>动态加载so文件</h1><h2 id="1-System-load-String-filePath"><a href="#1-System-load-String-filePath" class="headerlink" title="1. System.load(String filePath)"></a>1. System.load(String filePath)</h2><p>加载so文件分为动态加载和静态加载。</p><ol><li><p>静态加载就是通过<code>System.loadLibrary(Sting libname);</code>来直接加载，对于一个app它只能加载system的和我们自己添加到jniLibs下的so文件。<br><img src="http://7xj9f0.com1.z0.glb.clouddn.com/so_fix_libs_path.png" alt="图2-1"></p><p>这个是我的demo项目的路径，静态加载回去这些路径下找到对应的库，否则抛出异常。</p></li><li><p>动态加载这是通过<code>System.load(String filePath)</code>来加载filePath对应路径下的so文件，这个路径不可以是外置SDcard等拓展路径，必须是/data/**{package}下。</p></li></ol><p>所以下发的so没有权限放到图2-1下，只能通过加载的so文件路径的方式来动态加载so文件。</p><p>方案1： 将so文件copy到/data/**{package}下，system.load(filePath).</p><h2 id="2-支持静态加载"><a href="#2-支持静态加载" class="headerlink" title="2. 支持静态加载"></a>2. 支持静态加载</h2><p>但是我们这样做还是解决不了问题，因为有些so文件加载的过程是放到sdkxia的，如百度地图sdk，已经封装了加载so文件（静态加载），即使你已经实现了方案1仍然扔出<code>UnsatisfiedLinkError</code>的异常。<br>要弄清这个过程，就必须了解so的加载过程，以我的本地的android skd（Android）为例。<br>System源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">              Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>RunningTime<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(ClassLoader loader, String libname)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (libname.indexOf((<span class="keyword">int</span>)File.separatorChar) != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(</span><br><span class="line">  <span class="string">"Directory separator should not appear in library name: "</span> + libname);</span><br><span class="line">      &#125;</span><br><span class="line">      String libraryName = libname;</span><br><span class="line">      <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 去loade中查找libraryName命令的library</span></span><br><span class="line">          String filename = loader.findLibrary(libraryName);</span><br><span class="line">          <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">              <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">              <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">              <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                             System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          String error = doLoad(filename, loader);</span><br><span class="line">          <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String filename = System.mapLibraryName(libraryName);</span><br><span class="line">      List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      String lastError = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (String directory : getLibPaths()) &#123;</span><br><span class="line">          String candidate = directory + filename;</span><br><span class="line">          candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">              String error = doLoad(candidate, loader);</span><br><span class="line">              <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">              &#125;</span><br><span class="line">              lastError = error;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>代码中的loader是<code>ClassLoader</code>的对象，对于Android实际上是<code>PathClassLoader</code>,这个意思就是当有classLoader时就通过<code>PathClassLoader</code>的<code>findLibrary(libraryName)</code>来加载（这个好像加载class），若无classLoader就通过<code>mapLibraryName1（）</code></p><blockquote><p>建议大家看下native层怎么实现的：<a href="https://www.v2ex.com/t/364978" target="_blank" rel="noopener">深入理解 System.loadLibrary</a></p></blockquote><p>我们加载so看classLoader是怎么实现的，Android 5.0的源码源码：<br><a href="https://android.googlesource.com/platform/libcore/+/android-5.0.0_r6/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="noopener">BaseDexClassLoader.java的源码</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>pathList就是我们的DexPathList对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="comment">/** class definition context */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader definingContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of dex/resource (class path) elements.</span></span><br><span class="line"><span class="comment">     * Should be called pathElements, but the Facebook app uses reflection</span></span><br><span class="line"><span class="comment">     * to modify 'dexElements' (http://b/7726934).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] dexElements;</span><br><span class="line">    <span class="comment">/** List of native library directories. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File[] nativeLibraryDirectories;</span><br><span class="line">     …………</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">        String fileName = System.mapLibraryName(libraryName);</span><br><span class="line">        <span class="keyword">for</span> (File directory : nativeLibraryDirectories) &#123;</span><br><span class="line">            String path = <span class="keyword">new</span> File(directory, fileName).getPath();</span><br><span class="line">            <span class="keyword">if</span> (IoUtils.canOpenReadOnly(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吧，会先找system下的so文件，再找<code>nativeLibraryDirectories</code>下的，而这个<code>nativeLibraryDirectories</code>就是我们的自己项目中jniLibs下对应的so文件的路径。<br>当以当我们静态加载时，其实找的so文件就是<code>nativeLibraryDirectories</code>，所以我们可以以此作为突破口，利用反射，将这个nativeLibraryDirectories的开始处加上我们自己放so的文件夹下（感觉像QQ空间对class做patch的方式哦，其实替换旧的so文件这种可以可行的）。<br>开始hook啦。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PathClassLoader pathClassLoader = (PathClassLoader) context.getApplicationContext().getClassLoader();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object pathList = getPathList(pathClassLoader);</span><br><span class="line">                </span><br><span class="line">           <span class="comment">// 拿到nativeLibraryDirectories的Field</span></span><br><span class="line">           Field nativeLibraryDirectoriesField = pathList.getClass().getDeclaredField(<span class="string">"nativeLibraryDirectories"</span>);</span><br><span class="line">           nativeLibraryDirectoriesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">           File[] libPaths = (File[]) nativeLibraryDirectoriesField.get(pathList);</span><br><span class="line">           File[] envilLibPaths = <span class="keyword">new</span> File[libPaths.length + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">// 将存放我们自己so的文件夹加到第一位</span></span><br><span class="line">           envilLibPaths[<span class="number">0</span>] = dir;</span><br><span class="line">           <span class="comment">// 将原来的路径追加到后面</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; libPaths.length; i++) &#123;</span><br><span class="line">               envilLibPaths[i + <span class="number">1</span>] = libPaths[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 将新的nativeLibraryDirectories设置给pathList</span></span><br><span class="line">           nativeLibraryDirectoriesField.set(pathList, envilLibPaths);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>这个代码是在14-22都是ok的，但是23源码不是这样滴，看源码吧：<br><a href="https://android.googlesource.com/platform/libcore/+/android-6.0.1_r48/dalvik/src/main/java/dalvik/system/DexPathList.java" target="_blank" rel="noopener">23的源码</a>先放这,hook起来也不难。</p><blockquote><p>Android 23源码建议hook <code>nativeLibraryPathElements</code>这个而不是<code>nativeLibraryDirectories;</code></p></blockquote><p>方案2：Hook DexPathList的nativeLibraryPathElements或者nativeLibraryDirectories，将我们自定义存so文件的文件夹作为他们的第一个元素。</p><h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><p>刚开始我把所有视频相关的so文件扔到本地的一个文件下，再copy到/data/**{package}下，居然报<code>32-bit instead of 64-bit</code> 这个错误，我把so再放到jniLibs/armeabi下再跑可以啊，后来google了下发现有人在<a href="https://github.com/singwhatiwanna/dynamic-load-apk/issues/113" target="_blank" rel="noopener">动态化</a>时也遇到了，其中Anjon-github提到了一个方案：只要找任意一个32位的so文件（当然越小越好了）放到主程序中即可,于是我找了个1k的so文件放到了项目的jniLibs/armeabi下居然真的可以，这个原因不知为何，这个涉及到native代码，本人技术有限暂时没找到答案，不知道大家是否更好的解答或者解决方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着业务的增大，我们的业务代码也随之增多，包的大小是有增无减，所以适当的时候思考下:怎么做减法–减小包的体积。&lt;/p&gt;
&lt;p&gt;结合最近在做的公司的项目，觉得动态加载so文件是一个很好精简apk包的方法。举个例子，视频播放器的SDK（如IJKplayer，VLC player），他们的各种视频的解码器一般都是通过C/C++编译的so文件，这些so文件其实都不小，这样导致我们从市场上下载的apk包很大，所以能不能让so文件不随apk一起发布呢，而是按需下载(只有当需要播放视频时才去服务器下载，然后再在本地load)。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ownwell.github.io/categories/Android/"/>
    
    
      <category term="Android进阶" scheme="http://ownwell.github.io/tags/Android%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
</feed>
